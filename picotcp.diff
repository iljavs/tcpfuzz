diff -ruN picotcp/.git/config stack/picotcp/.git/config
--- picotcp/.git/config	2023-12-29 11:12:14.394606600 +0100
+++ stack/picotcp/.git/config	2023-12-29 11:06:34.076462400 +0100
@@ -1,11 +1,10 @@
 [core]
 	repositoryformatversion = 0
-	filemode = false
+	filemode = true
 	bare = false
 	logallrefupdates = true
-	ignorecase = true
 [remote "origin"]
-	url = https://github.com/tass-belgium/picotcp
+	url = https://github.com/tass-belgium/picotcp.git
 	fetch = +refs/heads/*:refs/remotes/origin/*
 [branch "master"]
 	remote = origin
diff -ruN picotcp/.git/hooks/fsmonitor-watchman.sample stack/picotcp/.git/hooks/fsmonitor-watchman.sample
--- picotcp/.git/hooks/fsmonitor-watchman.sample	2023-12-29 11:11:58.668662600 +0100
+++ stack/picotcp/.git/hooks/fsmonitor-watchman.sample	2023-12-29 11:06:34.085725100 +0100
@@ -8,102 +8,167 @@
 # (https://facebook.github.io/watchman/) with git to speed up detecting
 # new and modified files.
 #
-# The hook is passed a version (currently 1) and a time in nanoseconds
-# formatted as a string and outputs to stdout all files that have been
-# modified since the given time. Paths must be relative to the root of
-# the working tree and separated by a single NUL.
+# The hook is passed a version (currently 2) and last update token
+# formatted as a string and outputs to stdout a new update token and
+# all files that have been modified since the update token. Paths must
+# be relative to the root of the working tree and separated by a single NUL.
 #
 # To enable this hook, rename this file to "query-watchman" and set
 # 'git config core.fsmonitor .git/hooks/query-watchman'
 #
-my ($version, $time) = @ARGV;
+my ($version, $last_update_token) = @ARGV;
 
-# Check the hook interface version
+# Uncomment for debugging
+# print STDERR "$0 $version $last_update_token\n";
 
-if ($version == 1) {
-	# convert nanoseconds to seconds
-	# subtract one second to make sure watchman will return all changes
-	$time = int ($time / 1000000000) - 1;
-} else {
+# Check the hook interface version
+if ($version ne 2) {
 	die "Unsupported query-fsmonitor hook version '$version'.\n" .
 	    "Falling back to scanning...\n";
 }
 
-my $git_work_tree;
-if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-	$git_work_tree = Win32::GetCwd();
-	$git_work_tree =~ tr/\\/\//;
-} else {
-	require Cwd;
-	$git_work_tree = Cwd::cwd();
-}
+my $git_work_tree = get_working_dir();
 
 my $retry = 1;
 
+my $json_pkg;
+eval {
+	require JSON::XS;
+	$json_pkg = "JSON::XS";
+	1;
+} or do {
+	require JSON::PP;
+	$json_pkg = "JSON::PP";
+};
+
 launch_watchman();
 
 sub launch_watchman {
+	my $o = watchman_query();
+	if (is_work_tree_watched($o)) {
+		output_result($o->{clock}, @{$o->{files}});
+	}
+}
+
+sub output_result {
+	my ($clockid, @files) = @_;
+
+	# Uncomment for debugging watchman output
+	# open (my $fh, ">", ".git/watchman-output.out");
+	# binmode $fh, ":utf8";
+	# print $fh "$clockid\n@files\n";
+	# close $fh;
 
+	binmode STDOUT, ":utf8";
+	print $clockid;
+	print "\0";
+	local $, = "\0";
+	print @files;
+}
+
+sub watchman_clock {
+	my $response = qx/watchman clock "$git_work_tree"/;
+	die "Failed to get clock id on '$git_work_tree'.\n" .
+		"Falling back to scanning...\n" if $? != 0;
+
+	return $json_pkg->new->utf8->decode($response);
+}
+
+sub watchman_query {
 	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	    or die "open2() failed: $!\n" .
-	    "Falling back to scanning...\n";
+	or die "open2() failed: $!\n" .
+	"Falling back to scanning...\n";
 
 	# In the query expression below we're asking for names of files that
-	# changed since $time but were not transient (ie created after
-	# $time but no longer exist).
+	# changed since $last_update_token but not from the .git folder.
 	#
 	# To accomplish this, we're using the "since" generator to use the
 	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only.
-
+	# output to file names only. Then we're using the "expression" term to
+	# further constrain the results.
+	my $last_update_line = "";
+	if (substr($last_update_token, 0, 1) eq "c") {
+		$last_update_token = "\"$last_update_token\"";
+		$last_update_line = qq[\n"since": $last_update_token,];
+	}
 	my $query = <<"	END";
-		["query", "$git_work_tree", {
-			"since": $time,
-			"fields": ["name"]
+		["query", "$git_work_tree", {$last_update_line
+			"fields": ["name"],
+			"expression": ["not", ["dirname", ".git"]]
 		}]
 	END
 
+	# Uncomment for debugging the watchman query
+	# open (my $fh, ">", ".git/watchman-query.json");
+	# print $fh $query;
+	# close $fh;
+
 	print CHLD_IN $query;
 	close CHLD_IN;
 	my $response = do {local $/; <CHLD_OUT>};
 
+	# Uncomment for debugging the watch response
+	# open ($fh, ">", ".git/watchman-response.json");
+	# print $fh $response;
+	# close $fh;
+
 	die "Watchman: command returned no output.\n" .
-	    "Falling back to scanning...\n" if $response eq "";
+	"Falling back to scanning...\n" if $response eq "";
 	die "Watchman: command returned invalid output: $response\n" .
-	    "Falling back to scanning...\n" unless $response =~ /^\{/;
+	"Falling back to scanning...\n" unless $response =~ /^\{/;
 
-	my $json_pkg;
-	eval {
-		require JSON::XS;
-		$json_pkg = "JSON::XS";
-		1;
-	} or do {
-		require JSON::PP;
-		$json_pkg = "JSON::PP";
-	};
-
-	my $o = $json_pkg->new->utf8->decode($response);
+	return $json_pkg->new->utf8->decode($response);
+}
 
-	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		print STDERR "Adding '$git_work_tree' to watchman's watch list.\n";
+sub is_work_tree_watched {
+	my ($output) = @_;
+	my $error = $output->{error};
+	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
 		$retry--;
-		qx/watchman watch "$git_work_tree"/;
+		my $response = qx/watchman watch "$git_work_tree"/;
 		die "Failed to make watchman watch '$git_work_tree'.\n" .
 		    "Falling back to scanning...\n" if $? != 0;
+		$output = $json_pkg->new->utf8->decode($response);
+		$error = $output->{error};
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		# Uncomment for debugging watchman output
+		# open (my $fh, ">", ".git/watchman-output.out");
+		# close $fh;
 
 		# Watchman will always return all files on the first query so
 		# return the fast "everything is dirty" flag to git and do the
 		# Watchman query just to get it over with now so we won't pay
 		# the cost in git to look up each individual file.
-		print "/\0";
+		my $o = watchman_clock();
+		$error = $output->{error};
+
+		die "Watchman: $error.\n" .
+		"Falling back to scanning...\n" if $error;
+
+		output_result($o->{clock}, ("/"));
+		$last_update_token = $o->{clock};
+
 		eval { launch_watchman() };
-		exit 0;
+		return 0;
 	}
 
-	die "Watchman: $o->{error}.\n" .
-	    "Falling back to scanning...\n" if $o->{error};
+	die "Watchman: $error.\n" .
+	"Falling back to scanning...\n" if $error;
 
-	binmode STDOUT, ":utf8";
-	local $, = "\0";
-	print @{$o->{files}};
+	return 1;
+}
+
+sub get_working_dir {
+	my $working_dir;
+	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
+		$working_dir = Win32::GetCwd();
+		$working_dir =~ tr/\\/\//;
+	} else {
+		require Cwd;
+		$working_dir = Cwd::cwd();
+	}
+
+	return $working_dir;
 }
diff -ruN picotcp/.git/hooks/pre-commit.sample stack/picotcp/.git/hooks/pre-commit.sample
--- picotcp/.git/hooks/pre-commit.sample	2023-12-29 11:11:58.681227500 +0100
+++ stack/picotcp/.git/hooks/pre-commit.sample	2023-12-29 11:06:34.089027800 +0100
@@ -16,7 +16,7 @@
 fi
 
 # If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --bool hooks.allownonascii)
+allownonascii=$(git config --type=bool hooks.allownonascii)
 
 # Redirect output to stderr.
 exec 1>&2
diff -ruN picotcp/.git/hooks/pre-push.sample stack/picotcp/.git/hooks/pre-push.sample
--- picotcp/.git/hooks/pre-push.sample	2023-12-29 11:11:58.689164100 +0100
+++ stack/picotcp/.git/hooks/pre-push.sample	2023-12-29 11:06:34.092334700 +0100
@@ -14,7 +14,7 @@
 # Information about the commits which are being pushed is supplied as lines to
 # the standard input in the form:
 #
-#   <local ref> <local sha1> <remote ref> <remote sha1>
+#   <local ref> <local oid> <remote ref> <remote oid>
 #
 # This sample shows how to prevent push of commits where the log message starts
 # with "WIP" (work in progress).
@@ -22,27 +22,27 @@
 remote="$1"
 url="$2"
 
-z40=0000000000000000000000000000000000000000
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 
-while read local_ref local_sha remote_ref remote_sha
+while read local_ref local_oid remote_ref remote_oid
 do
-	if [ "$local_sha" = $z40 ]
+	if test "$local_oid" = "$zero"
 	then
 		# Handle delete
 		:
 	else
-		if [ "$remote_sha" = $z40 ]
+		if test "$remote_oid" = "$zero"
 		then
 			# New branch, examine all commits
-			range="$local_sha"
+			range="$local_oid"
 		else
 			# Update to existing branch, examine new commits
-			range="$remote_sha..$local_sha"
+			range="$remote_oid..$local_oid"
 		fi
 
 		# Check for WIP commit
-		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
-		if [ -n "$commit" ]
+		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
+		if test -n "$commit"
 		then
 			echo >&2 "Found WIP commit in $local_ref, not pushing"
 			exit 1
diff -ruN picotcp/.git/hooks/push-to-checkout.sample stack/picotcp/.git/hooks/push-to-checkout.sample
--- picotcp/.git/hooks/push-to-checkout.sample	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/.git/hooks/push-to-checkout.sample	2023-12-29 11:06:34.097625900 +0100
@@ -0,0 +1,78 @@
+#!/bin/sh
+
+# An example hook script to update a checked-out tree on a git push.
+#
+# This hook is invoked by git-receive-pack(1) when it reacts to git
+# push and updates reference(s) in its repository, and when the push
+# tries to update the branch that is currently checked out and the
+# receive.denyCurrentBranch configuration variable is set to
+# updateInstead.
+#
+# By default, such a push is refused if the working tree and the index
+# of the remote repository has any difference from the currently
+# checked out commit; when both the working tree and the index match
+# the current commit, they are updated to match the newly pushed tip
+# of the branch. This hook is to be used to override the default
+# behaviour; however the code below reimplements the default behaviour
+# as a starting point for convenient modification.
+#
+# The hook receives the commit with which the tip of the current
+# branch is going to be updated:
+commit=$1
+
+# It can exit with a non-zero status to refuse the push (when it does
+# so, it must not modify the index or the working tree).
+die () {
+	echo >&2 "$*"
+	exit 1
+}
+
+# Or it can make any necessary changes to the working tree and to the
+# index to bring them to the desired state when the tip of the current
+# branch is updated to the new commit, and exit with a zero status.
+#
+# For example, the hook can simply run git read-tree -u -m HEAD "$1"
+# in order to emulate git fetch that is run in the reverse direction
+# with git push, as the two-tree form of git read-tree -u -m is
+# essentially the same as git switch or git checkout that switches
+# branches while keeping the local changes in the working tree that do
+# not interfere with the difference between the branches.
+
+# The below is a more-or-less exact translation to shell of the C code
+# for the default behaviour for git's push-to-checkout hook defined in
+# the push_to_deploy() function in builtin/receive-pack.c.
+#
+# Note that the hook will be executed from the repository directory,
+# not from the working tree, so if you want to perform operations on
+# the working tree, you will have to adapt your code accordingly, e.g.
+# by adding "cd .." or using relative paths.
+
+if ! git update-index -q --ignore-submodules --refresh
+then
+	die "Up-to-date check failed"
+fi
+
+if ! git diff-files --quiet --ignore-submodules --
+then
+	die "Working directory has unstaged changes"
+fi
+
+# This is a rough translation of:
+#
+#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
+if git cat-file -e HEAD 2>/dev/null
+then
+	head=HEAD
+else
+	head=$(git hash-object -t tree --stdin </dev/null)
+fi
+
+if ! git diff-index --quiet --cached --ignore-submodules $head --
+then
+	die "Working directory has staged changes"
+fi
+
+if ! git read-tree -u -m "$commit"
+then
+	die "Could not update working tree to new HEAD"
+fi
diff -ruN picotcp/.git/hooks/update.sample stack/picotcp/.git/hooks/update.sample
--- picotcp/.git/hooks/update.sample	2023-12-29 11:11:58.716939800 +0100
+++ stack/picotcp/.git/hooks/update.sample	2023-12-29 11:06:34.099612300 +0100
@@ -43,11 +43,11 @@
 fi
 
 # --- Config
-allowunannotated=$(git config --bool hooks.allowunannotated)
-allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
-denycreatebranch=$(git config --bool hooks.denycreatebranch)
-allowdeletetag=$(git config --bool hooks.allowdeletetag)
-allowmodifytag=$(git config --bool hooks.allowmodifytag)
+allowunannotated=$(git config --type=bool hooks.allowunannotated)
+allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
+denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
+allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
+allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
 
 # check for no description
 projectdesc=$(sed -e '1q' "$GIT_DIR/description")
@@ -60,7 +60,7 @@
 
 # --- Check types
 # if $newrev is 0000...0000, it's a commit to delete a ref.
-zero="0000000000000000000000000000000000000000"
+zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
 if [ "$newrev" = "$zero" ]; then
 	newrev_type=delete
 else
Binary files picotcp/.git/index and stack/picotcp/.git/index differ
diff -ruN picotcp/.git/logs/HEAD stack/picotcp/.git/logs/HEAD
--- picotcp/.git/logs/HEAD	2023-12-29 11:12:14.386670900 +0100
+++ stack/picotcp/.git/logs/HEAD	2023-12-29 11:06:34.105561600 +0100
@@ -1 +1 @@
-0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja <ilja@sydney.localdomain> 1703844734 +0100	clone: from https://github.com/tass-belgium/picotcp
+0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja van Sprundel <ilja@linuxNode.(none)> 1699737730 +0100	clone: from https://github.com/tass-belgium/picotcp.git
diff -ruN picotcp/.git/logs/refs/heads/master stack/picotcp/.git/logs/refs/heads/master
--- picotcp/.git/logs/refs/heads/master	2023-12-29 11:12:14.387332200 +0100
+++ stack/picotcp/.git/logs/refs/heads/master	2023-12-29 11:06:34.108871900 +0100
@@ -1 +1 @@
-0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja <ilja@sydney.localdomain> 1703844734 +0100	clone: from https://github.com/tass-belgium/picotcp
+0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja van Sprundel <ilja@linuxNode.(none)> 1699737730 +0100	clone: from https://github.com/tass-belgium/picotcp.git
diff -ruN picotcp/.git/logs/refs/remotes/origin/HEAD stack/picotcp/.git/logs/refs/remotes/origin/HEAD
--- picotcp/.git/logs/refs/remotes/origin/HEAD	2023-12-29 11:12:14.381378800 +0100
+++ stack/picotcp/.git/logs/refs/remotes/origin/HEAD	2023-12-29 11:06:34.112176500 +0100
@@ -1 +1 @@
-0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja <ilja@sydney.localdomain> 1703844734 +0100	clone: from https://github.com/tass-belgium/picotcp
+0000000000000000000000000000000000000000 46120abecc9fb79f7dfb2cc8192341a42e40fc8b ilja van Sprundel <ilja@linuxNode.(none)> 1699737730 +0100	clone: from https://github.com/tass-belgium/picotcp.git
diff -ruN picotcp/build/include/arch/pico_arm9.h stack/picotcp/build/include/arch/pico_arm9.h
--- picotcp/build/include/arch/pico_arm9.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_arm9.h	2023-12-29 11:06:34.289412500 +0100
@@ -0,0 +1,35 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *********************************************************************/
+#define dbg(...) do {} while(0)
+
+/******************/
+
+/*** MACHINE CONFIGURATION ***/
+/* Temporary (POSIX) stuff. */
+#include <string.h>
+#include <unistd.h>
+
+extern volatile uint32_t __str9_tick;
+
+#define pico_native_malloc(x) calloc(x, 1)
+#define pico_native_free(x) free(x)
+
+static inline unsigned long PICO_TIME(void)
+{
+    register uint32_t tick = __str9_tick;
+    return tick / 1000;
+}
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    return __str9_tick;
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned long tick_now = __str9_tick;
+    while(tick_now == __str9_tick) ;
+}
+
diff -ruN picotcp/build/include/arch/pico_atsamd21j18.h stack/picotcp/build/include/arch/pico_atsamd21j18.h
--- picotcp/build/include/arch/pico_atsamd21j18.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_atsamd21j18.h	2023-12-29 11:06:34.291395800 +0100
@@ -0,0 +1,61 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *********************************************************************/
+
+/*** MACHINE CONFIGURATION ***/
+/* Temporary (POSIX) stuff. */
+#include <string.h>
+#include <unistd.h>
+
+/* Temporary debugging stuff. */
+#include <stdarg.h>
+#include "halUart.h"
+#include <stdio.h>
+
+static void print_uart(char *str)
+{
+    int i, len;
+    len = (int)strlen(str);
+    for (i = 0; i < len; i++) {
+        HAL_UartWriteByte(str[i]);
+        if (HAL_UartTxFull())
+            HAL_UartFlush();
+    }
+}
+
+static inline void sam_dbg(const char *format, ...)
+{
+    char msg[128] = { 0 };
+    va_list args;
+    va_start(args, format);
+    vsnprintf(msg, 256, format, args);
+    va_end(args);
+    print_uart(msg);
+}
+
+//#define dbg sam_dbg
+#define dbg(...) do { } while(0)
+
+extern volatile uint32_t sam_tick;
+
+#define pico_zalloc(x) calloc(x, 1)
+#define pico_free(x) free(x)
+
+static inline unsigned long PICO_TIME(void)
+{
+    register uint32_t tick = sam_tick;
+    return tick / 1000;
+}
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    return sam_tick;
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned long tick_now = sam_tick;
+    while(tick_now == sam_tick) ;
+}
+
diff -ruN picotcp/build/include/arch/pico_avr.h stack/picotcp/build/include/arch/pico_avr.h
--- picotcp/build/include/arch/pico_avr.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_avr.h	2023-12-29 11:06:34.292718400 +0100
@@ -0,0 +1,39 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#define dbg(...) do {} while(0)
+/* #define dbg printf */
+
+/*************************/
+
+/*** MACHINE CONFIGURATION ***/
+/* Temporary (POSIX) stuff. */
+#include <string.h>
+#include <stdio.h>
+#include <stdint.h>
+#include "pico_mm.h"
+
+extern volatile uint32_t __avr_tick;
+
+#define pico_zalloc(x) calloc(x, 1)
+#define pico_free(x) free(x)
+
+static inline unsigned long PICO_TIME(void)
+{
+    register uint32_t tick = __avr_tick;
+    return tick / 1000;
+}
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    return __avr_tick;
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned long tick_now = __avr_tick;
+    while(tick_now == __avr_tick) ;
+}
+
diff -ruN picotcp/build/include/arch/pico_cortex_m.h stack/picotcp/build/include/arch/pico_cortex_m.h
--- picotcp/build/include/arch/pico_cortex_m.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_cortex_m.h	2023-12-29 11:06:34.294041200 +0100
@@ -0,0 +1,12 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_CORTEX_M
+#define _INCLUDE_PICO_CORTEX_M
+
+#include "pico_generic_gcc.h"
+
+#endif  /* PICO_CORTEX_M */
+
diff -ruN picotcp/build/include/arch/pico_dos.h stack/picotcp/build/include/arch/pico_dos.h
--- picotcp/build/include/arch/pico_dos.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_dos.h	2023-12-29 11:06:34.296025100 +0100
@@ -0,0 +1,44 @@
+/*
+ * This is a picoTCP arch file for the DOS 16 bit target using OpenWatcom v1.9
+ * Copyright (C) 2015 Mateusz Viste
+ *
+ * This code is donated to the picoTCP project, and shares the same licensing,
+ * that is GNU GPLv2.
+ *
+ * See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ */
+
+#include <dos.h>   /* provides int86() along with the union REGS type */
+
+#ifndef PICO_SUPPORT_DOS_WATCOM
+#define PICO_SUPPORT_DOS_WATCOM
+
+#define dbg(...)
+
+#define pico_zalloc(x) calloc(x, 1)
+#define pico_free(x) free(x)
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    union REGS regs;
+    unsigned long ticks;
+    regs.h.ah = 0;          /* get system time (IBM BIOS call) - INT 1A,0 */
+    int86(0x1A, &regs, &regs);
+    ticks = regs.x.cx;      /* number of ticks since midnight (high word) */
+    ticks <<= 16;
+    ticks |= regs.x.dx;     /* number of ticks since midnight (low word) */
+    return (ticks * 55);    /* a tick is 55ms because the i8253 PIT runs at 18.2 Hz */
+}
+
+static inline unsigned long PICO_TIME(void)
+{
+    return (PICO_TIME_MS() / 1000);
+}
+
+static inline void PICO_IDLE(void)
+{
+    union REGS regs;
+    int86(0x28, &regs, &regs); /* DOS 2+ IDLE INTERRUPT */
+}
+
+#endif /* PICO_SUPPORT_DOS_WATCOM */
diff -ruN picotcp/build/include/arch/pico_esp8266.h stack/picotcp/build/include/arch/pico_esp8266.h
--- picotcp/build/include/arch/pico_esp8266.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_esp8266.h	2023-12-29 11:06:34.297347900 +0100
@@ -0,0 +1,58 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2014-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_ESP8266
+#define _INCLUDE_PICO_ESP8266
+
+#include <stdio.h>
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pico_constants.h"
+
+/* -------------- DEBUG ------------- */
+
+/* #define dbg(...) */
+#define dbg             printf
+
+/* -------------- MEMORY ------------- */
+extern void *pvPortMalloc( size_t xWantedSize );
+extern void vPortFree( void *pv );
+
+#define pico_free   vPortFree
+
+static inline void *pico_zalloc(size_t size)
+{
+    void *ptr = (void *)pvPortMalloc(size);
+
+    if(ptr)
+        memset(ptr, 0u, size);
+
+    return ptr;
+}
+
+/* -------------- TIME ------------- */
+
+extern volatile uint32_t esp_tick;
+
+static inline pico_time PICO_TIME_MS(void)
+{
+    return (pico_time) esp_tick;
+}
+
+static inline pico_time PICO_TIME(void)
+{
+    return PICO_TIME_MS() / 1000;
+}
+
+static inline void PICO_IDLE(void)
+{
+    uint32_t now = esp_tick;
+    while (now == esp_tick)
+        ;
+}
+
+#endif
diff -ruN picotcp/build/include/arch/pico_generic_gcc.h stack/picotcp/build/include/arch/pico_generic_gcc.h
--- picotcp/build/include/arch/pico_generic_gcc.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_generic_gcc.h	2023-12-29 11:06:34.298672500 +0100
@@ -0,0 +1,117 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_GCC
+#define _INCLUDE_PICO_GCC
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pico_constants.h"
+
+/* #define TIME_PRESCALE */
+
+/* monotonically increasing tick,
+ * typically incremented every millisecond in a systick interrupt */
+extern volatile unsigned int pico_ms_tick;
+
+#define dbg(...)
+
+#ifdef PICO_SUPPORT_PTHREAD
+    #define PICO_SUPPORT_MUTEX
+#endif
+
+#ifdef PICO_SUPPORT_RTOS
+    #define PICO_SUPPORT_MUTEX
+
+extern void *pico_mutex_init(void);
+extern void pico_mutex_lock(void*);
+extern void pico_mutex_unlock(void*);
+extern void *pvPortMalloc( size_t xSize );
+extern void vPortFree( void *pv );
+
+    #define pico_free(x) vPortFree(x)
+    #define free(x)      vPortFree(x)
+
+static inline void *pico_zalloc(size_t size)
+{
+    void *ptr = pvPortMalloc(size);
+
+    if(ptr)
+        memset(ptr, 0u, size);
+
+    return ptr;
+}
+
+/* time prescaler */
+#ifdef TIME_PRESCALE
+extern int32_t prescale_time;
+#endif
+
+static inline pico_time PICO_TIME_MS()
+{
+    #ifdef TIME_PRESCALE
+        return pico_ms_tick << prescale_time;
+    #else
+        return pico_ms_tick;
+    #endif
+}
+
+static inline pico_time PICO_TIME()
+{
+    #ifdef TIME_PRESCALE
+        return (pico_ms_tick / 1000) << prescale_time;
+    #else
+        return (pico_ms_tick / 1000);
+    #endif
+}
+
+static inline void PICO_IDLE(void)
+{
+    pico_time now = PICO_TIME_MS();
+    while(now == PICO_TIME_MS()) ;
+}
+
+#else /* NO RTOS SUPPORT */
+
+    #ifdef MEM_MEAS
+/* These functions should be implemented elsewhere */
+extern void *memmeas_zalloc(size_t size);
+extern void memmeas_free(void *);
+        #define pico_free(x)    memmeas_free(x)
+        #define pico_zalloc(x)  memmeas_zalloc(x)
+    #else
+/* Use plain C-lib malloc and free */
+        #define pico_free(x) free(x)
+static inline void *pico_zalloc(size_t size)
+{
+    void *ptr = malloc(size);
+    if(ptr)
+        memset(ptr, 0u, size);
+
+    return ptr;
+}
+    #endif
+
+static inline pico_time PICO_TIME_MS(void)
+{
+    return (pico_time)pico_ms_tick;
+}
+
+static inline pico_time PICO_TIME(void)
+{
+    return (pico_time)(PICO_TIME_MS() / 1000);
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned int now = pico_ms_tick;
+    while(now == pico_ms_tick) ;
+}
+
+#endif /* IFNDEF RTOS */
+
+#endif  /* PICO_GCC */
+
diff -ruN picotcp/build/include/arch/pico_linux.h stack/picotcp/build/include/arch/pico_linux.h
--- picotcp/build/include/arch/pico_linux.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_linux.h	2023-12-29 11:06:34.299993300 +0100
@@ -0,0 +1,33 @@
+#ifndef PICO_SUPPORT_LINUX
+#define PICO_SUPPORT_LINUX
+
+#include "linux/types.h"
+#include "linux/mm.h"
+#include "linux/slab.h"
+#include "linux/jiffies.h"
+
+#define dbg printk
+
+#define pico_zalloc(x) kcalloc(x, 1, GFP_ATOMIC) /* All allocations are GFP_ATOMIC for now */
+#define pico_free(x) kfree(x)
+
+
+static inline unsigned long PICO_TIME(void)
+{
+    return (unsigned long)(jiffies_to_msecs(jiffies) / 1000);
+}
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    return (unsigned long)jiffies_to_msecs(jiffies);
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned long now = jiffies;
+    while (now == jiffies) {
+        ;
+    }
+}
+
+#endif
diff -ruN picotcp/build/include/arch/pico_mbed.h stack/picotcp/build/include/arch/pico_mbed.h
--- picotcp/build/include/arch/pico_mbed.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_mbed.h	2023-12-29 11:06:34.301316800 +0100
@@ -0,0 +1,185 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   File: pico_mbed.h
+   Author: Toon Peters
+ *********************************************************************/
+
+#ifndef PICO_SUPPORT_MBED
+#define PICO_SUPPORT_MBED
+#include <stdio.h>
+#include <pico_queue.h>
+/* #include "mbed.h" */
+/* #include "serial_api.h" */
+
+/* #define TIME_PRESCALE */
+/* #define PICO_MEASURE_STACK */
+/* #define MEMORY_MEASURE */
+/*
+   Debug needs initialization:
+ * void serial_init       (serial_t *obj, PinName tx, PinName rx);
+ * void serial_baud       (serial_t *obj, int baudrate);
+ * void serial_format     (serial_t *obj, int data_bits, SerialParity parity, int stop_bits);
+ */
+
+#define dbg(...)
+
+/*
+   #define MEMORY_MEASURE
+   #define JENKINS_DEBUG
+ */
+
+/* Intended for Mr. Jenkins endurance test loggings */
+#ifdef JENKINS_DEBUG
+#include "PicoTerm.h"
+#define jenkins_dbg ptm_dbg
+#endif
+
+#ifdef PICO_MEASURE_STACK
+
+extern int freeStack;
+#define STACK_TOTAL_WORDS   1000u
+#define STACK_PATTERN       (0xC0CAC01Au)
+
+void stack_fill_pattern(void *ptr);
+void stack_count_free_words(void *ptr);
+int stack_get_free_words(void);
+#else
+#define stack_fill_pattern(...) do {} while(0)
+#define stack_count_free_words(...) do {} while(0)
+#define stack_get_free_words() (0)
+#endif
+
+#ifdef MEMORY_MEASURE /* in case, comment out the two defines above me. */
+extern uint32_t max_mem;
+extern uint32_t cur_mem;
+
+struct mem_chunk_stats {
+#ifdef MEMORY_MEASURE_ADV
+    uint32_t signature;
+    void *mem;
+#endif
+    uint32_t size;
+};
+
+static inline void *pico_zalloc(int x)
+{
+    struct mem_chunk_stats *stats;
+    if ((cur_mem + x) > (10 * 1024))
+        return NULL;
+
+    stats = (struct mem_chunk_stats *)calloc(x + sizeof(struct mem_chunk_stats), 1);
+#ifdef MEMORY_MEASURE_ADV
+    stats->signature = 0xdeadbeef;
+    stats->mem = ((uint8_t *)stats) + sizeof(struct mem_chunk_stats);
+#endif
+    stats->size = x;
+
+    /* Intended for Mr. Jenkins endurance test loggings */
+    #ifdef JENKINS_DEBUG
+    if (!stats) {
+        jenkins_dbg(">> OUT OF MEM\n");
+        while(1) ;
+        ;
+    }
+
+    #endif
+    cur_mem += x;
+    if (cur_mem > max_mem) {
+        max_mem = cur_mem;
+        /*      printf("max mem: %lu\n", max_mem); */
+    }
+
+#ifdef MEMORY_MEASURE_ADV
+    return (void*)(stats->mem);
+#else
+    return (void*) (((uint8_t *)stats) + sizeof(struct mem_chunk_stats));
+#endif
+}
+
+static inline void pico_free(void *x)
+{
+    struct mem_chunk_stats *stats = (struct mem_chunk_stats *) ((uint8_t *)x - sizeof(struct mem_chunk_stats));
+
+    #ifdef JENKINS_DEBUG
+    #ifdef MEMORY_MEASURE_ADV
+    if ((stats->signature != 0xdeadbeef) || (x != stats->mem)) {
+        jenkins_dbg(">> FREE ERROR: caller is %p\n", __builtin_return_address(0));
+        while(1) ;
+        ;
+    }
+
+    #endif
+
+    #endif
+
+    cur_mem -= stats->size;
+    memset(stats, 0, sizeof(struct mem_chunk_stats));
+    free(stats);
+}
+#else
+
+#define pico_zalloc(x) calloc(x, 1)
+#define pico_free(x) free(x)
+
+#endif
+
+#define PICO_SUPPORT_MUTEX
+extern void *pico_mutex_init(void);
+extern void pico_mutex_lock(void*);
+extern void pico_mutex_unlock(void*);
+extern void pico_mutex_deinit(void*);
+
+extern uint32_t os_time;
+extern pico_time local_time;
+extern uint32_t last_os_time;
+
+#ifdef TIME_PRESCALE
+extern int32_t prescale_time;
+#endif
+
+#define UPDATE_LOCAL_TIME() do {local_time = local_time + ((pico_time)os_time - (pico_time)last_os_time);last_os_time = os_time;} while(0)
+
+static inline pico_time PICO_TIME(void)
+{
+    UPDATE_LOCAL_TIME();
+  #ifdef TIME_PRESCALE
+    return (prescale_time < 0) ? (pico_time)(local_time / 1000 << (-prescale_time)) : \
+           (pico_time)(local_time / 1000 >> prescale_time);
+  #else
+    return (pico_time)(local_time / 1000);
+  #endif
+}
+
+static inline pico_time PICO_TIME_MS(void)
+{
+    UPDATE_LOCAL_TIME();
+  #ifdef TIME_PRESCALE
+    return (prescale_time < 0) ? (pico_time)(local_time << (-prescale_time)) : \
+           (pico_time)(local_time >> prescale_time);
+  #else
+    return (pico_time)local_time;
+  #endif
+}
+
+static inline void PICO_IDLE(void)
+{
+    /* TODO needs implementation */
+}
+/*
+   static inline void PICO_DEBUG(const char * formatter, ... )
+   {
+   char buffer[256];
+   char *ptr;
+   va_list args;
+   va_start(args, formatter);
+   vsnprintf(buffer, 256, formatter, args);
+   ptr = buffer;
+   while(*ptr != '\0')
+    serial_putc(serial_t *obj, (int) (*(ptr++)));
+   va_end(args);
+   //TODO implement serial_t
+   }*/
+
+#endif
diff -ruN picotcp/build/include/arch/pico_msp430.h stack/picotcp/build/include/arch/pico_msp430.h
--- picotcp/build/include/arch/pico_msp430.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_msp430.h	2023-12-29 11:06:34.302639900 +0100
@@ -0,0 +1,38 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_LPC
+#define _INCLUDE_PICO_LPC
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pico_constants.h"
+
+extern pico_time msp430_time_s(void);
+extern pico_time msp430_time_ms(void);
+extern void *malloc(size_t);
+extern void free(void *);
+
+
+#define PICO_TIME() msp430_time_s()
+#define PICO_TIME_MS() msp430_time_ms()
+#define PICO_IDLE() do {} while(0)
+
+#define pico_free(x) free(x)
+
+static inline void *pico_zalloc(size_t size)
+{
+    void *ptr = malloc(size);
+
+    if(ptr)
+        memset(ptr, 0u, size);
+
+    return ptr;
+}
+
+#define dbg(...)
+
+#endif
diff -ruN picotcp/build/include/arch/pico_none.h stack/picotcp/build/include/arch/pico_none.h
--- picotcp/build/include/arch/pico_none.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_none.h	2023-12-29 11:06:34.303962100 +0100
@@ -0,0 +1,22 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *********************************************************************/
+
+#ifndef PICO_SUPPORT_ARCHNONE
+#define PICO_SUPPORT_ARCHNONE
+
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+#define dbg(...) do {} while(0)
+#define pico_zalloc(x) NULL
+#define pico_free(x) do {} while(0)
+#define PICO_TIME() 666
+#define PICO_TIME_MS() 666000
+#define PICO_IDLE() do {} while(0)
+
+#endif  /* PICO_SUPPORT_ARCHNONE */
+
diff -ruN picotcp/build/include/arch/pico_pic24.h stack/picotcp/build/include/arch/pico_pic24.h
--- picotcp/build/include/arch/pico_pic24.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_pic24.h	2023-12-29 11:06:34.304622500 +0100
@@ -0,0 +1,100 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *********************************************************************/
+#ifndef PICO_SUPPORT_PIC24
+#define PICO_SUPPORT_PIC24
+#define dbg printf
+/* #define dbg(...) */
+
+/*************************/
+
+/*** MACHINE CONFIGURATION ***/
+#include <stdio.h>
+#include <stdint.h>
+
+/* #include "phalox_development_board.h" */
+
+#ifndef __PIC24F__
+#define __PIC24F__
+#endif
+
+/*
+   #ifndef __PIC24FJ256GA106__
+   #define __PIC24FJ256GA106__
+   #endif
+ */
+
+#ifndef PICO_MAX_SOCKET_FRAMES
+#define PICO_MAX_SOCKET_FRAMES 16
+#endif
+
+/* Device header file */
+
+#if defined(__PIC24E__)
+# include <p24Exxxx.h>
+#elif defined(__PIC24F__)
+# include <p24Fxxxx.h>
+#elif defined(__PIC24H__)
+# include <p24Hxxxx.h>
+#endif
+
+
+#define TIMBASE_INT_E         IEC0bits.T2IE
+
+#ifdef PICO_SUPPORT_DEBUG_MEMORY
+static inline void *pico_zalloc(int len)
+{
+    /* dbg("%s: Alloc object of len %d, caller: %p\n", __FUNCTION__, len, __builtin_return_address(0)); */
+    return calloc(len, 1);
+}
+
+static inline void pico_free(void *tgt)
+{
+    /* dbg("%s: Discarded object @%p, caller: %p\n", __FUNCTION__, tgt, __builtin_return_address(0)); */
+    free(tgt);
+}
+#else
+# define pico_zalloc(x) calloc(x, 1)
+# define pico_free(x) free(x)
+#endif
+
+extern void *pvPortMalloc( size_t xWantedSize );
+extern volatile pico_time __pic24_tick;
+
+static inline unsigned long PICO_TIME(void)
+{
+    unsigned long tick;
+    /* Disable timer interrupts */
+    TIMBASE_INT_E = 0;
+    tick = __pic24_tick;
+    /* Enable timer interrupts */
+    TIMBASE_INT_E = 1;
+    return tick / 1000;
+}
+
+static inline unsigned long PICO_TIME_MS(void)
+{
+    unsigned long tick;
+    /* Disable timer interrupts */
+    TIMBASE_INT_E = 0;
+    tick = __pic24_tick;
+    /* Enable timer interrupts */
+    TIMBASE_INT_E = 1;
+    return tick;
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned long tick_now;
+    /* Disable timer interrupts */
+    TIMBASE_INT_E = 0;
+    tick_now = (unsigned long)pico_tick;
+    /* Enable timer interrupts */
+    TIMBASE_INT_E = 1;
+    /* Doesn't matter that this call isn't interrupt safe, */
+    /* we just check for the value to change */
+    while(tick_now == __pic24_tick) ;
+}
+
+#endif
diff -ruN picotcp/build/include/arch/pico_pic32.h stack/picotcp/build/include/arch/pico_pic32.h
--- picotcp/build/include/arch/pico_pic32.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_pic32.h	2023-12-29 11:06:34.306606500 +0100
@@ -0,0 +1,54 @@
+
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_PIC32
+#define _INCLUDE_PICO_PIC32
+
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include "pico_constants.h"
+
+/* monotonically increasing tick,
+ * typically incremented every millisecond in a systick interrupt */
+extern volatile unsigned int pico_ms_tick;
+
+#ifdef PIC32_NO_PRINTF
+#define dbg(...) do {} while(0)
+#else
+#define dbg printf
+#endif
+
+/* Use plain C-lib malloc and free */
+#define pico_free(x) free(x)
+
+static inline void *pico_zalloc(size_t size)
+{
+    void *ptr = malloc(size);
+    if(ptr)
+        memset(ptr, 0u, size);
+
+    return ptr;
+}
+
+static inline pico_time PICO_TIME_MS(void)
+{
+    return (pico_time)pico_ms_tick;
+}
+
+static inline pico_time PICO_TIME(void)
+{
+    return (pico_time)(PICO_TIME_MS() / 1000);
+}
+
+static inline void PICO_IDLE(void)
+{
+    unsigned int now = pico_ms_tick;
+    while(now == pico_ms_tick) ;
+}
+
+#endif  /* PICO_PIC32 */
+
diff -ruN picotcp/build/include/arch/pico_posix.h stack/picotcp/build/include/arch/pico_posix.h
--- picotcp/build/include/arch/pico_posix.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/arch/pico_posix.h	2023-12-29 11:06:34.307929300 +0100
@@ -0,0 +1,137 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *********************************************************************/
+
+#ifndef PICO_SUPPORT_POSIX
+#define PICO_SUPPORT_POSIX
+
+#include <string.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <sys/time.h>
+
+/*
+   #define MEMORY_MEASURE
+   #define TIME_PRESCALE
+   #define PICO_SUPPORT_THREADING
+ */
+#define dbg printf
+
+#define stack_fill_pattern(...) do {} while(0)
+#define stack_count_free_words(...) do {} while(0)
+#define stack_get_free_words() (0)
+
+/* measure allocated memory */
+#ifdef MEMORY_MEASURE
+extern uint32_t max_mem;
+extern uint32_t cur_mem;
+
+static inline void *pico_zalloc(int x)
+{
+    uint32_t *ptr;
+    if ((cur_mem + x) > (10 * 1024))
+        return NULL;
+
+    ptr = (uint32_t *)calloc(x + 4, 1);
+    *ptr = (uint32_t)x;
+    cur_mem += x;
+    if (cur_mem > max_mem) {
+        max_mem = cur_mem;
+    }
+
+    return (void*)(ptr + 1);
+}
+
+static inline void pico_free(void *x)
+{
+    uint32_t *ptr = (uint32_t*)(((uint8_t *)x) - 4);
+    cur_mem -= *ptr;
+    free(ptr);
+}
+#else
+#define pico_zalloc(x) calloc(x, 1)
+#define pico_free(x) free(x)
+#endif
+
+/* time prescaler */
+#ifdef TIME_PRESCALE
+extern int32_t prescale_time;
+#endif
+
+#if defined(PICO_SUPPORT_RTOS) || defined (PICO_SUPPORT_PTHREAD)
+/* pico_ms_tick must be defined */
+extern volatile uint32_t pico_ms_tick;
+
+static inline uint32_t PICO_TIME(void)
+{
+    #ifdef TIME_PRESCALE
+        return (pico_ms_tick / 1000) << prescale_time;
+    #else
+        return (pico_ms_tick / 1000);
+    #endif
+}
+
+static inline uint32_t PICO_TIME_MS(void)
+{
+    #ifdef TIME_PRESCALE
+        return pico_ms_tick << prescale_time;
+    #else
+        return pico_ms_tick;
+    #endif
+}
+
+#else
+
+static inline uint32_t PICO_TIME(void)
+{
+    struct timeval t;
+    gettimeofday(&t, NULL);
+  #ifdef TIME_PRESCALE
+    return (prescale_time < 0) ? (uint32_t)(t.tv_sec / 1000 << (-prescale_time)) : \
+           (uint32_t)(t.tv_sec / 1000 >> prescale_time);
+  #else
+    return (uint32_t)t.tv_sec;
+  #endif
+}
+
+static inline uint32_t PICO_TIME_MS(void)
+{
+    struct timeval t;
+    gettimeofday(&t, NULL);
+  #ifdef TIME_PRESCALER
+    uint32_t tmp = ((t.tv_sec * 1000) + (t.tv_usec / 1000));
+    return (prescale_time < 0) ? (uint32_t)(tmp / 1000 << (-prescale_time)) : \
+           (uint32_t)(tmp / 1000 >> prescale_time);
+  #else
+    return (uint32_t)((t.tv_sec * 1000) + (t.tv_usec / 1000));
+  #endif
+}
+#endif
+
+#ifdef PICO_SUPPORT_THREADING
+#define PICO_SUPPORT_MUTEX
+/* mutex implementations */
+extern void *pico_mutex_init(void);
+extern void pico_mutex_lock(void *mux);
+extern void pico_mutex_unlock(void *mux);
+
+/* semaphore implementations (only used in wrapper code) */
+extern void *pico_sem_init(void);
+extern void pico_sem_destroy(void *sem);
+extern void pico_sem_post(void *sem);
+/* returns -1 on timeout (in ms), else returns 0 */
+/* if timeout < 0, the semaphore waits forever */
+extern int pico_sem_wait(void *sem, int timeout);
+
+/* thread implementations */
+extern void *pico_thread_create(void *(*routine)(void *), void *arg);
+#endif  /* PICO_SUPPORT_THREADING */
+
+static inline void PICO_IDLE(void)
+{
+    usleep(5000);
+}
+
+#endif  /* PICO_SUPPORT_POSIX */
+
diff -ruN picotcp/build/include/heap.h stack/picotcp/build/include/heap.h
--- picotcp/build/include/heap.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/heap.h	2023-12-29 11:06:34.264942400 +0100
@@ -0,0 +1,107 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#define MAX_BLOCK_SIZE 1600
+#define MAX_BLOCK_COUNT 16
+
+#define DECLARE_HEAP(type, orderby) \
+    struct heap_ ## type {   \
+        uint32_t size;    \
+        uint32_t n;       \
+        type *top[MAX_BLOCK_COUNT];        \
+    }; \
+    typedef struct heap_ ## type heap_ ## type; \
+    static inline type* heap_get_element(struct heap_ ## type *heap, uint32_t idx) \
+    { \
+        uint32_t elements_per_block = MAX_BLOCK_SIZE/sizeof(type); \
+        return &heap->top[idx/elements_per_block][idx%elements_per_block];\
+    } \
+    static inline int8_t heap_increase_size(struct heap_ ## type *heap) \
+    {\
+        type *newTop; \
+        uint32_t elements_per_block = MAX_BLOCK_SIZE/sizeof(type); \
+        uint32_t elements = (heap->n + 1)%elements_per_block;\
+        elements = elements?elements:elements_per_block;\
+        if (heap->n+1 > elements_per_block * MAX_BLOCK_COUNT){\
+            return -1;\
+        }\
+        newTop = PICO_ZALLOC(elements*sizeof(type)); \
+        if(!newTop) { \
+            return -1; \
+        } \
+        if (heap->top[heap->n/elements_per_block])  { \
+            memcpy(newTop, heap->top[heap->n/elements_per_block], (elements - 1) * sizeof(type)); \
+            PICO_FREE(heap->top[heap->n/elements_per_block]); \
+        } \
+        heap->top[heap->n/elements_per_block] = newTop;             \
+        heap->size++;                                                               \
+        return 0;                                                               \
+    }\
+    static inline int heap_insert(struct heap_ ## type *heap, type * el) \
+    { \
+        type *half;                                                                 \
+        uint32_t i; \
+        if (++heap->n >= heap->size) {                                                \
+            if (heap_increase_size(heap)){                                                    \
+                heap->n--;                                                           \
+                return -1;                                                           \
+            }                                                                       \
+        }                                                                             \
+        if (heap->n == 1) {                                                       \
+            memcpy(heap_get_element(heap, 1), el, sizeof(type));                                    \
+            return 0;                                                                   \
+        }                                                                             \
+        i = heap->n;                                                                    \
+        half = heap_get_element(heap, i/2);                                                   \
+        while ( (i > 1) && (half->orderby > el->orderby) ) {        \
+            memcpy(heap_get_element(heap, i), heap_get_element(heap, i / 2), sizeof(type));                     \
+            i /= 2;                                                                     \
+            half = heap_get_element(heap, i/2);                                                   \
+        }             \
+        memcpy(heap_get_element(heap, i), el, sizeof(type));                                      \
+        return 0;                                                                     \
+    } \
+    static inline int heap_peek(struct heap_ ## type *heap, type * first) \
+    { \
+        type *last;           \
+        type *left_child;           \
+        type *right_child;           \
+        uint32_t i, child;        \
+        if(heap->n == 0) {    \
+            return -1;          \
+        }                     \
+        memcpy(first, heap_get_element(heap, 1), sizeof(type));   \
+        last = heap_get_element(heap, heap->n--);                 \
+        for(i = 1; (i * 2u) <= heap->n; i = child) {   \
+            child = 2u * i;                              \
+            right_child = heap_get_element(heap, child+1);     \
+            left_child = heap_get_element(heap, child);      \
+            if ((child != heap->n) &&                   \
+                (right_child->orderby          \
+                < left_child->orderby))           \
+                child++;                                \
+            left_child = heap_get_element(heap, child);      \
+            if (last->orderby >                         \
+                left_child->orderby)               \
+                memcpy(heap_get_element(heap,i), heap_get_element(heap,child), \
+                       sizeof(type));                  \
+            else                                        \
+                break;                                  \
+        }                                             \
+        memcpy(heap_get_element(heap, i), last, sizeof(type));    \
+        return 0;                                     \
+    } \
+    static inline type *heap_first(heap_ ## type * heap)  \
+    { \
+        if (heap->n == 0)     \
+            return NULL;        \
+        return heap_get_element(heap, 1);  \
+    } \
+    static inline heap_ ## type *heap_init(void) \
+    { \
+        heap_ ## type * p = (heap_ ## type *)PICO_ZALLOC(sizeof(heap_ ## type));  \
+        return p;     \
+    } \
+
diff -ruN picotcp/build/include/pico_6lowpan.h stack/picotcp/build/include/pico_6lowpan.h
--- picotcp/build/include/pico_6lowpan.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_6lowpan.h	2023-12-29 11:06:34.309252000 +0100
@@ -0,0 +1,40 @@
+/*********************************************************************
+ PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights
+ reserved.  See LICENSE and COPYING for usage.
+
+ Authors: Jelle De Vleeschouwer
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_6LOWPAN
+#define INCLUDE_PICO_6LOWPAN
+
+#include "pico_protocol.h"
+#include "pico_device.h"
+#include "pico_config.h"
+#include "pico_frame.h"
+
+#define PICO_6LP_FLAG_LOWPAN (0x01)
+#define PICO_6LP_FLAG_NOMAC  (0x02)
+
+#ifdef PICO_SUPPORT_6LOWPAN
+#define PICO_DEV_IS_6LOWPAN(dev) ((dev) && ((dev)->hostvars.lowpan_flags & PICO_6LP_FLAG_LOWPAN))
+#define PICO_DEV_IS_NOMAC(dev) ((dev) && ((dev)->hostvars.lowpan_flags & PICO_6LP_FLAG_NOMAC))
+#else
+#define PICO_DEV_IS_6LOWPAN(dev) (0)
+#define PICO_DEV_IS_NOMAC(dev) (0)
+#endif
+
+/******************************************************************************
+ * Public variables
+ ******************************************************************************/
+
+extern struct pico_protocol pico_proto_6lowpan;
+
+/******************************************************************************
+ * Public functions
+ ******************************************************************************/
+
+int32_t pico_6lowpan_pull(struct pico_frame *f);
+int pico_6lowpan_init(void);
+
+#endif /* INCLUDE_PICO_6LOWPAN */
diff -ruN picotcp/build/include/pico_6lowpan_ll.h stack/picotcp/build/include/pico_6lowpan_ll.h
--- picotcp/build/include/pico_6lowpan_ll.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_6lowpan_ll.h	2023-12-29 11:06:34.310574600 +0100
@@ -0,0 +1,122 @@
+/*********************************************************************
+ PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights
+ reserved.  See LICENSE and COPYING for usage.
+
+ Authors: Jelle De Vleeschouwer
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_6LOWPAN_LL
+#define INCLUDE_PICO_6LOWPAN_LL
+
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_6lowpan.h"
+#include "pico_device.h"
+#include "pico_config.h"
+#include "pico_frame.h"
+#include "pico_ipv6.h"
+
+/* Possible actions to perform on a received frame */
+#define FRAME_6LOWPAN_LL_RELEASE    (-1)
+#define FRAME_6LOWPAN_LL_DISCARD    (-2)
+
+/*******************************************************************************
+ *  CTX
+ ******************************************************************************/
+
+#ifdef PICO_6LOWPAN_IPHC_ENABLED
+
+#define PICO_IPHC_CTX_COMPRESS (0x01u)
+
+struct iphc_ctx
+{
+    struct pico_device *dev;
+    struct pico_ip6 prefix;
+    uint8_t id;
+    uint8_t size;
+    uint8_t flags;
+    pico_time lifetime;
+};
+
+/*
+ *  Looks up a context entry for a particular IPv6-address contained in 'addr' and returns it.
+ *  Returns NULL if no entry is found. (See RFC4944)
+ */
+struct iphc_ctx * ctx_lookup(struct pico_ip6 addr);
+
+/*
+ *  Looks up a context entry that belongs to a certain context identifier.
+ *  Returns NULL if no belonging entry is found. (See RFC4944)
+ */
+struct iphc_ctx * ctx_lookup_id(uint8_t id);
+
+/*
+ *  Creates a new, or updates and existing, context entry for a certain IPv6 address. (See RFC4944)
+ */
+void ctx_update(struct pico_ip6 addr, uint8_t id, uint8_t size, pico_time lifetime, uint8_t flags, struct pico_device *dev);
+
+#endif
+
+/******************************************************************************
+ * Interface with device drivers
+ ******************************************************************************/
+
+struct pico_dev_6lowpan
+{
+    /* Interface with picoTCP */
+    struct pico_device dev;
+
+    /* Transmit-function:
+     *
+     *  @param dev  The device who's send-function got called
+     *  @param _buf Buffer containing the frame to be send over the network
+     *  @param len  Length of _buf
+     *  @param src  Link Layer source address of the device (IETF-endianness)
+     *  @param dst  Link layer destination address of the device (IETF-endianness)
+     *
+     *  @return length of the frame that is transmitted on success, -1 on failure
+     */
+    int (* send)(struct pico_device *dev, void *_buf, int len, union pico_ll_addr src, union pico_ll_addr dst);
+};
+
+/* Initialisation routine for 6LoWPAN specific devices */
+int pico_dev_6lowpan_init(struct pico_dev_6lowpan *dev, const char *name, uint8_t *mac, enum pico_ll_mode ll_mode, uint16_t mtu, uint8_t nomac,
+                          int (* send)(struct pico_device *dev, void *_buf, int len, union pico_ll_addr src, union pico_ll_addr dst),
+                          int (* poll)(struct pico_device *dev, int loop_score));
+
+/******************************************************************************
+ * Interface with link layer
+ ******************************************************************************/
+
+struct pico_6lowpan_ll_protocol
+{
+    int32_t (* process_in)(struct pico_frame *f);
+    int32_t (* process_out)(struct pico_frame *f);
+    int32_t (* estimate)(struct pico_frame *f);
+    int32_t (* addr_from_buf)(union pico_ll_addr *addr, uint8_t *buf);
+    int32_t (* addr_from_net)(union pico_ll_addr *addr, struct pico_frame *f, int32_t dest);
+    int32_t (* addr_len)(union pico_ll_addr *addr);
+    int32_t (* addr_cmp)(union pico_ll_addr *a, union pico_ll_addr *b);
+    int32_t (* addr_iid)(uint8_t *iid, union pico_ll_addr *addr);
+    struct pico_frame * (*alloc)(struct pico_device *dev, uint16_t size);
+};
+
+/******************************************************************************
+ * Public variables
+ ******************************************************************************/
+
+extern struct pico_6lowpan_ll_protocol pico_6lowpan_lls[];
+extern struct pico_protocol pico_proto_6lowpan_ll;
+
+/******************************************************************************
+ * Public functions
+ ******************************************************************************/
+
+void pico_6lowpan_ll_init(void);
+int32_t pico_6lowpan_ll_push(struct pico_frame *f);
+int32_t pico_6lowpan_ll_pull(struct pico_frame *f);
+int32_t frame_6lowpan_ll_store_addr(struct pico_frame *f);
+int32_t pico_6lowpan_ll_sendto_dev(struct pico_device *dev, struct pico_frame *f);
+int32_t pico_6lowpan_stack_recv(struct pico_device *dev, uint8_t *buffer, uint32_t len, union pico_ll_addr *src, union pico_ll_addr *dst);
+
+#endif /* INCLUDE_PICO_6LOWPAN_LL */
diff -ruN picotcp/build/include/pico_802154.h stack/picotcp/build/include/pico_802154.h
--- picotcp/build/include/pico_802154.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_802154.h	2023-12-29 11:06:34.311899500 +0100
@@ -0,0 +1,40 @@
+/*********************************************************************
+ PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights
+ reserved.  See LICENSE and COPYING for usage.
+
+ Authors: Jelle De Vleeschouwer
+ *********************************************************************/
+#ifndef INCLUDE_PICO_802154
+#define INCLUDE_PICO_802154
+
+#include "pico_device.h"
+#include "pico_config.h"
+#include "pico_6lowpan_ll.h"
+
+/*******************************************************************************
+ * Size definitions
+ ******************************************************************************/
+
+#define MTU_802154_PHY                  (128u)
+#define MTU_802154_MAC                  (125u) // 127 - Frame Check Sequence
+
+#define SIZE_802154_MHR_MIN             (5u)
+#define SIZE_802154_MHR_MAX             (23u)
+#define SIZE_802154_FCS                 (2u)
+#define SIZE_802154_LEN                 (1u)
+#define SIZE_802154_PAN                 (2u)
+
+/*******************************************************************************
+ * Structure definitions
+ ******************************************************************************/
+
+PACKED_STRUCT_DEF pico_802154_hdr
+{
+    uint16_t fcf;
+    uint8_t seq;
+    uint16_t pan_id;
+};
+
+extern const struct pico_6lowpan_ll_protocol pico_6lowpan_ll_802154;
+
+#endif /* INCLUDE_PICO_802154 */
diff -ruN picotcp/build/include/pico_addressing.h stack/picotcp/build/include/pico_addressing.h
--- picotcp/build/include/pico_addressing.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_addressing.h	2023-12-29 11:06:34.266265100 +0100
@@ -0,0 +1,127 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_ADDRESSING
+#define INCLUDE_PICO_ADDRESSING
+
+#include "pico_config.h"
+#include "pico_constants.h"
+
+PACKED_STRUCT_DEF pico_ip4
+{
+    uint32_t addr;
+};
+
+PACKED_STRUCT_DEF pico_ip6
+{
+    uint8_t addr[16];
+};
+
+union pico_address
+{
+    struct pico_ip4 ip4;
+    struct pico_ip6 ip6;
+};
+
+/******************************************************************************
+ *  Ethernet Address Definitions
+ ******************************************************************************/
+
+PACKED_STRUCT_DEF pico_eth
+{
+    uint8_t addr[6];
+    uint8_t padding[2];
+};
+
+extern const uint8_t PICO_ETHADDR_ALL[];
+
+/******************************************************************************
+ *  Generic 6LoWPAN Address Definitions
+ ******************************************************************************/
+
+/* 6lowpan supports 16-bit short addresses */
+PACKED_STRUCT_DEF pico_6lowpan_short
+{
+    uint16_t addr;
+};
+
+/* And also EUI-64 addresses */
+PACKED_STRUCT_DEF pico_6lowpan_ext
+{
+    uint8_t addr[8];
+};
+
+/* Address memory as either a short 16-bit address or a 64-bit address */
+union pico_6lowpan_u
+{
+    uint8_t data[8];
+    struct pico_6lowpan_short _short;
+    struct pico_6lowpan_ext _ext;
+};
+
+/* Info data structure to pass to pico_device_init by the device driver */
+struct pico_6lowpan_info
+{
+    struct pico_6lowpan_short addr_short;
+    struct pico_6lowpan_ext addr_ext;
+    struct pico_6lowpan_short pan_id;
+};
+
+/* Different addressing modes for IEEE802.15.4 addresses */
+#define AM_6LOWPAN_NONE      (0u)
+#define AM_6LOWPAN_RES       (1u)
+#define AM_6LOWPAN_SHORT     (2u)
+#define AM_6LOWPAN_EXT       (3u)
+#define SIZE_6LOWPAN_SHORT   (2u)
+#define SIZE_6LOWPAN_EXT     (8u)
+#define SIZE_6LOWPAN(m) (((m) == 2) ? (2) : (((m) == 3) ? (8) : (0)))
+
+/******************************************************************************
+ *  Generic 6LoWPAN Address Definitions
+ ******************************************************************************/
+
+/* Storage data structure for IEEE802.15.4 addresses */
+struct pico_802154
+{
+    union pico_6lowpan_u addr;
+    uint8_t mode;
+};
+
+/******************************************************************************
+ *  Link Layer addresses
+ ******************************************************************************/
+
+#define IID_16(iid) (0 == (iid)[2] && 0xff == (iid)[3] && 0xfe == (iid)[4] && 0 == (iid)[5])
+
+enum pico_ll_mode
+{
+    LL_MODE_ETHERNET = 0,
+#ifdef PICO_SUPPORT_802154
+    LL_MODE_IEEE802154,
+#endif
+};
+
+union pico_ll_addr
+{
+    struct pico_eth eth;
+    struct pico_802154 pan;
+};
+
+PACKED_STRUCT_DEF pico_trans
+{
+    uint16_t sport;
+    uint16_t dport;
+};
+
+/* Here are some protocols. */
+#define PICO_PROTO_IPV4   0
+#define PICO_PROTO_ICMP4  1
+#define PICO_PROTO_IGMP  2
+#define PICO_PROTO_TCP    6
+#define PICO_PROTO_UDP    17
+#define PICO_PROTO_IPV6   41
+#define PICO_PROTO_ICMP6  58
+
+#endif
diff -ruN picotcp/build/include/pico_aodv.h stack/picotcp/build/include/pico_aodv.h
--- picotcp/build/include/pico_aodv.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_aodv.h	2023-12-29 11:06:34.313883000 +0100
@@ -0,0 +1,130 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2015-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Author: Daniele Lacamera <daniele.lacamera@altran.com>
+ *********************************************************************/
+#ifndef PICO_AODV_H_
+#define PICO_AODV_H_
+
+/* RFC3561 */
+#define PICO_AODV_PORT (654)
+
+/* RFC3561 $10 */
+#define AODV_ACTIVE_ROUTE_TIMEOUT     (8000u) /* Conservative value for link breakage detection */
+#define AODV_DELETE_PERIOD            (5 * AODV_ACTIVE_ROUTE_TIMEOUT) /* Recommended value K = 5 */
+#define AODV_ALLOWED_HELLO_LOSS       (4) /* conservative */
+#define AODV_NET_DIAMETER             ((uint8_t)(35))
+#define AODV_RREQ_RETRIES             (2)
+#define AODV_NODE_TRAVERSAL_TIME      (40)
+#define AODV_HELLO_INTERVAL           (1000)
+#define AODV_LOCAL_ADD_TTL            2
+#define AODV_RREQ_RATELIMIT           (10)
+#define AODV_TIMEOUT_BUFFER           (2)
+#define AODV_TTL_START                ((uint8_t)(1))
+#define AODV_TTL_INCREMENT            2
+#define AODV_TTL_THRESHOLD            ((uint8_t)(7))
+#define AODV_RERR_RATELIMIT           (10)
+#define AODV_MAX_REPAIR_TTL           ((uint8_t)(AODV_NET_DIAMETER / 3))
+#define AODV_MY_ROUTE_TIMEOUT         (2 * AODV_ACTIVE_ROUTE_TIMEOUT)
+#define AODV_NET_TRAVERSAL_TIME       (2 * AODV_NODE_TRAVERSAL_TIME * AODV_NET_DIAMETER)
+#define AODV_BLACKLIST_TIMEOUT        (AODV_RREQ_RETRIES * AODV_NET_TRAVERSAL_TIME)
+#define AODV_NEXT_HOP_WAIT            (AODV_NODE_TRAVERSAL_TIME + 10)
+#define AODV_PATH_DISCOVERY_TIME      (2 * AODV_NET_TRAVERSAL_TIME)
+#define AODV_RING_TRAVERSAL_TIME(ttl)   (2 * AODV_NODE_TRAVERSAL_TIME * (ttl + AODV_TIMEOUT_BUFFER))
+/* End section RFC3561 $10 */
+
+
+#define AODV_TYPE_RREQ 1
+#define AODV_TYPE_RREP 2
+#define AODV_TYPE_RERR 3
+#define AODV_TYPE_RACK 4
+
+PACKED_STRUCT_DEF pico_aodv_rreq
+{
+    uint8_t type;
+    uint16_t req_flags;
+    uint8_t hop_count;
+    uint32_t rreq_id;
+    uint32_t dest;
+    uint32_t dseq;
+    uint32_t orig;
+    uint32_t oseq;
+};
+
+#define AODV_RREQ_FLAG_J 0x8000
+#define AODV_RREQ_FLAG_R 0x4000
+#define AODV_RREQ_FLAG_G 0x2000
+#define AODV_RREQ_FLAG_D 0x1000
+#define AODV_RREQ_FLAG_U 0x0800
+#define AODV_RREQ_FLAG_RESERVED 0x07FF
+
+PACKED_STRUCT_DEF pico_aodv_rrep
+{
+    uint8_t type;
+    uint8_t rep_flags;
+    uint8_t prefix_sz;
+    uint8_t hop_count;
+    uint32_t dest;
+    uint32_t dseq;
+    uint32_t orig;
+    uint32_t lifetime;
+};
+
+#define AODV_RREP_MAX_PREFIX 0x1F
+#define AODV_RREP_FLAG_R 0x80
+#define AODV_RREP_FLAG_A 0x40
+#define AODV_RREP_FLAG_RESERVED 0x3F
+
+#define PICO_AODV_NODE_NEW          0x0000
+#define PICO_AODV_NODE_SYNC         0x0001
+#define PICO_AODV_NODE_REQUESTING   0x0002
+#define PICO_AODV_NODE_ROUTE_UP     0x0004
+#define PICO_AODV_NODE_ROUTE_DOWN   0x0008
+#define PICO_AODV_NODE_IDLING       0x0010
+#define PICO_AODV_NODE_UNREACH      0x0020
+
+#define PICO_AODV_ACTIVE(node) ((node->flags & PICO_AODV_NODE_ROUTE_UP) && (node->flags & PICO_AODV_NODE_ROUTE_DOWN))
+
+
+struct pico_aodv_node
+{
+    union pico_address dest;
+    pico_time last_seen;
+    pico_time fwd_time;
+    uint32_t dseq;
+    uint16_t flags;
+    uint8_t metric;
+    uint8_t ring_ttl;
+    uint8_t rreq_retry;
+};
+
+PACKED_STRUCT_DEF pico_aodv_unreachable
+{
+    uint32_t addr;
+    uint32_t dseq;
+};
+
+PACKED_STRUCT_DEF pico_aodv_rerr
+{
+    uint8_t type;
+    uint16_t rerr_flags;
+    uint8_t dst_count;
+    uint32_t unreach_addr;
+    uint32_t unreach_dseq;
+    struct pico_aodv_unreachable unreach[1]; /* unrechable nodes: must be at least 1. See dst_count field above */
+};
+
+PACKED_STRUCT_DEF pico_aodv_rack
+{
+    uint8_t type;
+    uint8_t reserved;
+};
+
+int pico_aodv_init(void);
+int pico_aodv_add(struct pico_device *dev);
+int pico_aodv_lookup(const union pico_address *addr);
+void pico_aodv_refresh(const union pico_address *addr);
+#endif
diff -ruN picotcp/build/include/pico_arp.h stack/picotcp/build/include/pico_arp.h
--- picotcp/build/include/pico_arp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_arp.h	2023-12-29 11:06:34.315206100 +0100
@@ -0,0 +1,35 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_ARP
+#define INCLUDE_PICO_ARP
+#include "pico_eth.h"
+#include "pico_device.h"
+
+int pico_arp_receive(struct pico_frame *);
+
+
+struct pico_eth *pico_arp_get(struct pico_frame *f);
+int32_t pico_arp_request(struct pico_device *dev, struct pico_ip4 *dst, uint8_t type);
+
+#define PICO_ARP_STATUS_REACHABLE 0x00
+#define PICO_ARP_STATUS_PERMANENT 0x01
+#define PICO_ARP_STATUS_STALE     0x02
+
+#define PICO_ARP_QUERY    0x00
+#define PICO_ARP_PROBE    0x01
+#define PICO_ARP_ANNOUNCE 0x02
+
+#define PICO_ARP_CONFLICT_REASON_CONFLICT 0
+#define PICO_ARP_CONFLICT_REASON_PROBE 1
+
+struct pico_eth *pico_arp_lookup(struct pico_ip4 *dst);
+struct pico_ip4 *pico_arp_reverse_lookup(struct pico_eth *dst);
+int pico_arp_create_entry(uint8_t*hwaddr, struct pico_ip4 ipv4, struct pico_device*dev);
+int pico_arp_get_neighbors(struct pico_device *dev, struct pico_ip4 *neighbors, int maxlen);
+void pico_arp_register_ipconflict(struct pico_ip4 *ip, struct pico_eth *mac, void (*cb)(int reason));
+void pico_arp_postpone(struct pico_frame *f);
+void pico_arp_init(void);
+#endif
diff -ruN picotcp/build/include/pico_config.h stack/picotcp/build/include/pico_config.h
--- picotcp/build/include/pico_config.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_config.h	2023-12-29 11:06:34.268249500 +0100
@@ -0,0 +1,243 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#include "pico_defines.h"
+#ifndef INCLUDE_PICO_CONFIG
+#define INCLUDE_PICO_CONFIG
+#ifndef __KERNEL__
+#include <stddef.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#else
+#include <linux/types.h>
+#endif
+
+#if defined __IAR_SYSTEMS_ICC__ || defined ATOP
+#   define PACKED_STRUCT_DEF __packed struct
+#   define PEDANTIC_STRUCT_DEF __packed struct
+#   define PACKED_UNION_DEF  __packed union
+#   define PACKED __packed
+#   define WEAK
+#elif defined __WATCOMC__
+#   define PACKED_STRUCT_DEF   _Packed struct
+#   define PEDANTIC_STRUCT_DEF struct
+#   define PACKED_UNION_DEF    _Packed union
+#   define WEAK
+#else
+#   define PACKED_STRUCT_DEF struct __attribute__((packed))
+#   define PEDANTIC_STRUCT_DEF struct
+#   define PACKED_UNION_DEF  union   /* Sane compilers do not require packed unions */
+#   define PACKED __attribute__((packed))
+#   define WEAK __attribute__((weak))
+#   ifdef __GNUC__
+#       define GCC_VERSION (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__)
+#       if ((GCC_VERSION >= 40800))
+#           define BYTESWAP_GCC
+#       endif
+#   endif
+#endif
+
+#ifdef PICO_BIGENDIAN
+
+# define PICO_IDETH_IPV4 0x0800
+# define PICO_IDETH_ARP 0x0806
+# define PICO_IDETH_IPV6 0x86DD
+
+# define PICO_ARP_REQUEST 0x0001
+# define PICO_ARP_REPLY   0x0002
+# define PICO_ARP_HTYPE_ETH 0x0001
+
+#define short_be(x) (x)
+#define long_be(x) (x)
+#define long_long_be(x) (x)
+
+static inline uint16_t short_from(void *_p)
+{
+    unsigned char *p = (unsigned char *)_p;
+    uint16_t r, p0, p1;
+    p0 = p[0];
+    p1 = p[1];
+    r = (p0 << 8) + p1;
+    return r;
+}
+
+static inline uint32_t long_from(void *_p)
+{
+    unsigned char *p = (unsigned char *)_p;
+    uint32_t r, p0, p1, p2, p3;
+    p0 = p[0];
+    p1 = p[1];
+    p2 = p[2];
+    p3 = p[3];
+    r = (p0 << 24) + (p1 << 16) + (p2 << 8) + p3;
+    return r;
+}
+
+#else
+
+static inline uint16_t short_from(void *_p)
+{
+    unsigned char *p = (unsigned char *)_p;
+    uint16_t r, _p0, _p1;
+    _p0 = p[0];
+    _p1 = p[1];
+    r = (uint16_t)((_p1 << 8u) + _p0);
+    return r;
+}
+
+static inline uint32_t long_from(void *_p)
+{
+    unsigned char *p = (unsigned char *)_p;
+    uint32_t r, _p0, _p1, _p2, _p3;
+    _p0 = p[0];
+    _p1 = p[1];
+    _p2 = p[2];
+    _p3 = p[3];
+    r = (_p3 << 24) + (_p2 << 16) + (_p1 << 8) + _p0;
+    return r;
+}
+
+
+# define PICO_IDETH_IPV4 0x0008
+# define PICO_IDETH_ARP 0x0608
+# define PICO_IDETH_IPV6 0xDD86
+
+# define PICO_ARP_REQUEST 0x0100
+# define PICO_ARP_REPLY   0x0200
+# define PICO_ARP_HTYPE_ETH 0x0100
+
+#   ifndef BYTESWAP_GCC
+static inline uint16_t short_be(uint16_t le)
+{
+    return (uint16_t)(((le & 0xFFu) << 8) | ((le >> 8u) & 0xFFu));
+}
+
+static inline uint32_t long_be(uint32_t le)
+{
+    uint8_t *b = (uint8_t *)&le;
+    uint32_t be = 0;
+    uint32_t b0, b1, b2;
+    b0 = b[0];
+    b1 = b[1];
+    b2 = b[2];
+    be = b[3] + (b2 << 8) + (b1 << 16) + (b0 << 24);
+    return be;
+}
+static inline uint64_t long_long_be(uint64_t le)
+{
+    uint8_t *b = (uint8_t *)&le;
+    uint64_t be = 0;
+    uint64_t b0, b1, b2, b3, b4, b5, b6;
+    b0 = b[0];
+    b1 = b[1];
+    b2 = b[2];
+    b3 = b[3];
+    b4 = b[4];
+    b5 = b[5];
+    b6 = b[6];
+    be = b[7] + (b6 << 8) + (b5 << 16) + (b4 << 24) + (b3 << 32) + (b2 << 40) + (b1 << 48) + (b0 << 56);
+    return be;
+}
+#   else
+/*
+   extern uint32_t __builtin_bswap32(uint32_t);
+   extern uint16_t __builtin_bswap16(uint16_t);
+   extern uint64_t __builtin_bswap64(uint64_t);
+ */
+
+static inline uint32_t long_be(uint32_t le)
+{
+    return (uint32_t)__builtin_bswap32(le);
+}
+
+static inline uint16_t short_be(uint16_t le)
+{
+    return (uint16_t)__builtin_bswap16(le);
+}
+
+static inline uint64_t long_long_be(uint64_t le)
+{
+    return (uint64_t)__builtin_bswap64(le);
+}
+
+#   endif /* BYTESWAP_GCC */
+#endif
+
+/* Mockables */
+#if defined UNIT_TEST
+#   define MOCKABLE __attribute__((weak))
+#else
+#   define MOCKABLE
+#endif
+
+#include "pico_constants.h"
+#include "pico_mm.h"
+
+#define IGNORE_PARAMETER(x)  ((void)x)
+
+#define PICO_MEM_DEFAULT_SLAB_SIZE 1600
+#define PICO_MEM_PAGE_SIZE 4096
+#define PICO_MEM_PAGE_LIFETIME 100
+#define PICO_MIN_HEAP_SIZE 600
+#define PICO_MIN_SLAB_SIZE 1200
+#define PICO_MAX_SLAB_SIZE 1600
+#define PICO_MEM_MINIMUM_OBJECT_SIZE 4
+
+/*** *** *** *** *** *** ***
+ *** PLATFORM SPECIFIC   ***
+ *** *** *** *** *** *** ***/
+#if defined PICO_PORT_CUSTOM
+# include "pico_port.h"
+#elif defined CORTEX_M4_HARDFLOAT
+# include "arch/pico_cortex_m.h"
+#elif defined CORTEX_M4_SOFTFLOAT
+# include "arch/pico_cortex_m.h"
+#elif defined CORTEX_M3
+# include "arch/pico_cortex_m.h"
+#elif defined CORTEX_M0
+# include "arch/pico_cortex_m.h"
+#elif defined DOS_WATCOM
+# include "arch/pico_dos.h"
+#elif defined PIC24
+# include "arch/pico_pic24.h"
+#elif defined PIC32
+# include "arch/pico_pic32.h"
+#elif defined MSP430
+# include "arch/pico_msp430.h"
+#elif defined MBED_TEST
+# include "arch/pico_mbed.h"
+#elif defined AVR
+# include "arch/pico_avr.h"
+#elif defined ARM9
+# include "arch/pico_arm9.h"
+#elif defined ESP8266
+# include "arch/pico_esp8266.h"
+#elif defined ATSAMD21J18
+# include "arch/pico_atsamd21j18.h"
+#elif defined MT7681
+# include "arch/pico_generic_gcc.h"
+#elif defined FAULTY
+# include "../test/pico_faulty.h"
+#elif defined ARCHNONE
+# include "arch/pico_none.h"
+#elif defined GENERIC
+# include "arch/pico_generic_gcc.h"
+#elif defined __KERNEL__
+# include "arch/pico_linux.h"
+/* #elif defined ... */
+#else
+# include "arch/pico_posix.h"
+#endif
+
+#ifdef PICO_SUPPORT_MM
+#define PICO_ZALLOC(x) pico_mem_zalloc(x)
+#define PICO_FREE(x) pico_mem_free(x)
+#else
+#define PICO_ZALLOC(x) pico_zalloc(x)
+#define PICO_FREE(x) pico_free(x)
+#endif  /* PICO_SUPPORT_MM */
+
+#endif
diff -ruN picotcp/build/include/pico_constants.h stack/picotcp/build/include/pico_constants.h
--- picotcp/build/include/pico_constants.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_constants.h	2023-12-29 11:06:34.269572400 +0100
@@ -0,0 +1,58 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_CONST
+#define INCLUDE_PICO_CONST
+/* Included from pico_config.h */
+
+/** Non-endian dependant constants */
+#define PICO_SIZE_IP4    4
+#define PICO_SIZE_IP6   16
+#define PICO_SIZE_ETH    6
+#define PICO_SIZE_TRANS  8
+#define PICO_SIZE_IEEE802154_EXT (8u)
+#define PICO_SIZE_IEEE802154_SHORT (2u)
+
+/** Endian-dependant constants **/
+typedef uint64_t pico_time;
+extern volatile uint64_t pico_tick;
+
+
+/*** *** *** *** *** *** ***
+ ***     ARP CONFIG      ***
+ *** *** *** *** *** *** ***/
+
+#include "pico_addressing.h"
+
+/* Maximum amount of accepted ARP requests per burst interval */
+#define PICO_ARP_MAX_RATE 1
+/* Duration of the burst interval in milliseconds */
+#define PICO_ARP_INTERVAL 1000
+
+/* Add well-known host numbers here. (bigendian constants only beyond this point) */
+#define PICO_IP4_ANY (0x00000000U)
+#define PICO_IP4_BCAST (0xffffffffU)
+
+#define PICO_IEEE802154_BCAST (0xffffu)
+
+/* defined in modules/pico_ipv6.c */
+#ifdef PICO_SUPPORT_IPV6
+extern const uint8_t PICO_IPV6_ANY[PICO_SIZE_IP6];
+#endif
+
+static inline uint32_t pico_hash(const void *buf, uint32_t size)
+{
+    uint32_t hash = 5381;
+    uint32_t i;
+    const uint8_t *ptr = (const uint8_t *)buf;
+    for(i = 0; i < size; i++)
+        hash = ((hash << 5) + hash) + ptr[i]; /* hash * 33 + char */
+    return hash;
+}
+
+/* Debug */
+/* #define PICO_SUPPORT_DEBUG_MEMORY */
+/* #define PICO_SUPPORT_DEBUG_TOOLS */
+#endif
diff -ruN picotcp/build/include/pico_defines.h stack/picotcp/build/include/pico_defines.h
--- picotcp/build/include/pico_defines.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_defines.h	2023-12-29 11:06:34.263619700 +0100
@@ -0,0 +1,33 @@
+/* PicoTCP - Definition file - DO NOT EDIT */
+/* This file is automatically generated at compile time */
+#ifndef PICO_DEFINES_H
+#define PICO_DEFINES_H
+
+#define PICO_SUPPORT_TFTP
+#define PICO_SUPPORT_AODV
+#define PICO_SUPPORT_ETH
+#define PICO_SUPPORT_IPV4
+#define PICO_SUPPORT_IPV4FRAG
+#define PICO_SUPPORT_ICMP4
+#define PICO_SUPPORT_PING
+#define PICO_SUPPORT_TCP
+#define PICO_SUPPORT_UDP
+#define PICO_SUPPORT_MCAST
+#define PICO_SUPPORT_IGMP
+#define PICO_SUPPORT_MLD
+#define PICO_SUPPORT_NAT
+#define PICO_SUPPORT_DEVLOOP
+#define PICO_SUPPORT_DHCPC
+#define PICO_SUPPORT_DHCPD
+#define PICO_SUPPORT_DNS_CLIENT
+#define PICO_SUPPORT_MDNS
+#define PICO_SUPPORT_DNS_SD
+#define PICO_SUPPORT_IPFILTER
+#define PICO_SUPPORT_CRC
+#define PICO_SUPPORT_SLAACV4
+#define PICO_SUPPORT_IPV6
+#define PICO_SUPPORT_ICMP6
+#define PICO_SUPPORT_IPV6FRAG
+#define PICO_SUPPORT_SNTP_CLIENT
+#define PICO_SUPPORT_PPP
+#endif
diff -ruN picotcp/build/include/pico_dev_ipc.h stack/picotcp/build/include/pico_dev_ipc.h
--- picotcp/build/include/pico_dev_ipc.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_ipc.h	2023-12-29 11:06:34.317189600 +0100
@@ -0,0 +1,15 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_IPC
+#define INCLUDE_PICO_IPC
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_ipc_destroy(struct pico_device *ipc);
+struct pico_device *pico_ipc_create(const char *sock_path, const char *name, const uint8_t *mac);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_loop.h stack/picotcp/build/include/pico_dev_loop.h
--- picotcp/build/include/pico_dev_loop.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_loop.h	2023-12-29 11:06:34.318511100 +0100
@@ -0,0 +1,15 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_LOOP
+#define INCLUDE_PICO_LOOP
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_loop_destroy(struct pico_device *loop);
+struct pico_device *pico_loop_create(void);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_mock.h stack/picotcp/build/include/pico_dev_mock.h
--- picotcp/build/include/pico_dev_mock.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_mock.h	2023-12-29 11:06:34.320495400 +0100
@@ -0,0 +1,47 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_MOCK
+#define INCLUDE_PICO_MOCK
+#include "pico_config.h"
+#include "pico_device.h"
+
+
+struct mock_frame {
+    uint8_t*buffer;
+    int len;
+    int read;
+
+    struct mock_frame*next;
+};
+
+struct mock_device {
+    struct pico_device*dev;
+    struct mock_frame*in_head;
+    struct mock_frame*in_tail;
+    struct mock_frame*out_head;
+    struct mock_frame*out_tail;
+
+    uint8_t*mac;
+
+};
+
+struct mock_device;
+/* A mockup-device for the purpose of testing. It provides a couple of extra "network"-functions, which represent the network-side of the device. A network_send will result in mock_poll reading something, a network_read will see if the stack has sent anything through our mock-device. */
+void pico_mock_destroy(struct pico_device *dev);
+struct mock_device *pico_mock_create(uint8_t*mac);
+
+int pico_mock_network_read(struct mock_device*mock, void *buf, int len);
+int pico_mock_network_write(struct mock_device*mock, const void *buf, int len);
+
+/* TODO */
+/* we could use a few checking functions, e.g. one to see if it's a valid IP packet, if it's TCP, if the IP-address matches,... */
+/* That would be useful to avoid having to manually create buffers of what you expect, probably with masks for things that are random,... */
+uint32_t mock_get_sender_ip4(struct mock_device*mock, void*buf, int len);
+
+int mock_ip_protocol(struct mock_device*mock, void*buf, int len);
+int mock_icmp_type(struct mock_device*mock, void*buf, int len);
+int mock_icmp_code(struct mock_device*mock, void*buf, int len);
+#endif
diff -ruN picotcp/build/include/pico_dev_null.h stack/picotcp/build/include/pico_dev_null.h
--- picotcp/build/include/pico_dev_null.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_null.h	2023-12-29 11:06:34.322478900 +0100
@@ -0,0 +1,15 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_NULL
+#define INCLUDE_PICO_NULL
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_null_destroy(struct pico_device *null);
+struct pico_device *pico_null_create(const char *name);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_pcap.h stack/picotcp/build/include/pico_dev_pcap.h
--- picotcp/build/include/pico_dev_pcap.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_pcap.h	2023-12-29 11:06:34.324463100 +0100
@@ -0,0 +1,19 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+
+   Author: Daniele Lacamera <daniele.lacamera@altran.com>
+ *********************************************************************/
+#ifndef INCLUDE_PICO_PCAP
+#define INCLUDE_PICO_PCAP
+#include "pico_config.h"
+#include "pico_device.h"
+#include <pcap.h>
+
+void pico_pcap_destroy(struct pico_device *pcap);
+struct pico_device *pico_pcap_create_live(char *ifname, char *name, uint8_t *mac);
+struct pico_device *pico_pcap_create_fromfile(char *filename, char *name, uint8_t *mac);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_ppp.h stack/picotcp/build/include/pico_dev_ppp.h
--- picotcp/build/include/pico_dev_ppp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_ppp.h	2023-12-29 11:06:34.325785800 +0100
@@ -0,0 +1,26 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012 TASS Belgium NV. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_PPP
+#define INCLUDE_PICO_PPP
+
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_ppp_destroy(struct pico_device *ppp);
+struct pico_device *pico_ppp_create(void);
+
+int pico_ppp_connect(struct pico_device *dev);
+int pico_ppp_disconnect(struct pico_device *dev);
+
+int pico_ppp_set_serial_read(struct pico_device *dev, int (*sread)(struct pico_device *, void *, int));
+int pico_ppp_set_serial_write(struct pico_device *dev, int (*swrite)(struct pico_device *, const void *, int));
+int pico_ppp_set_serial_set_speed(struct pico_device *dev, int (*sspeed)(struct pico_device *, uint32_t));
+
+int pico_ppp_set_apn(struct pico_device *dev, const char *apn);
+int pico_ppp_set_username(struct pico_device *dev, const char *username);
+int pico_ppp_set_password(struct pico_device *dev, const char *password);
+
+#endif /* INCLUDE_PICO_PPP */
diff -ruN picotcp/build/include/pico_dev_radio_mgr.h stack/picotcp/build/include/pico_dev_radio_mgr.h
--- picotcp/build/include/pico_dev_radio_mgr.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_radio_mgr.h	2023-12-29 11:06:34.327769000 +0100
@@ -0,0 +1,14 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See LICENSE and COPYING for usage.
+
+   Authors: Jelle De Vleeschouwer
+ *********************************************************************/
+
+#ifndef __PICO_DEV_RADIO_MGR_H_
+#define __PICO_DEV_RADIO_MGR_H_
+
+/* Start listening for TCP connection requests on 'LISTENING_PORT' */
+int pico_radio_mgr_start(void);
+
+#endif
diff -ruN picotcp/build/include/pico_dev_radiotest.h stack/picotcp/build/include/pico_dev_radiotest.h
--- picotcp/build/include/pico_dev_radiotest.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_radiotest.h	2023-12-29 11:06:34.329092000 +0100
@@ -0,0 +1,16 @@
+/*********************************************************************
+ PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+ See LICENSE and COPYING for usage.
+
+ Authors: Daniele Lacamera, Jelle De Vleeschouwer
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_DEV_RADIOTEST
+#define INCLUDE_PICO_DEV_RADIOTEST
+
+#include "pico_device.h"
+#include "pico_config.h"
+
+struct pico_device *pico_radiotest_create(uint8_t addr, uint8_t area0, uint8_t area1, int loop, char *dump);
+
+#endif /* INCLUDE_PICO_DEV_RADIOTEST */
diff -ruN picotcp/build/include/pico_dev_tap.h stack/picotcp/build/include/pico_dev_tap.h
--- picotcp/build/include/pico_dev_tap.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_tap.h	2023-12-29 11:06:34.331076100 +0100
@@ -0,0 +1,15 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_TAP
+#define INCLUDE_PICO_TAP
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_tap_destroy(struct pico_device *tap);
+struct pico_device *pico_tap_create(char *name);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_tap_windows.h stack/picotcp/build/include/pico_dev_tap_windows.h
--- picotcp/build/include/pico_dev_tap_windows.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_tap_windows.h	2023-12-29 11:06:34.333059900 +0100
@@ -0,0 +1,17 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2014-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_TAP
+#define INCLUDE_PICO_TAP
+#include "pico_config.h"
+#include "pico_device.h"
+
+/* will look for the first TAP device available, and use it */
+struct pico_device *pico_tap_create(char *name, uint8_t *mac);
+/* TODO: not implemented yet */
+/* void pico_tap_destroy(struct pico_device *null); */
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_tap_windows_private.h stack/picotcp/build/include/pico_dev_tap_windows_private.h
--- picotcp/build/include/pico_dev_tap_windows_private.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_tap_windows_private.h	2023-12-29 11:06:34.335044000 +0100
@@ -0,0 +1,89 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2014-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Maxime Vincent
+            Based on the OpenVPN tun.c driver, under GPL
+
+   NOTES: This is the Windows-only driver, a Linux-equivalent is available, too
+          You need to have an OpenVPN TUN/TAP network adapter installed, first
+          This driver is barely working:
+ * Only TAP-mode is supported (TUN is not)
+ * it will simply open the first TAP device it can find
+ * there is memory being allocated that's never freed
+ * there is no destroy function, yet
+ * it has only been tested on a Windows 7 machine
+ *********************************************************************/
+
+#ifndef __PICO_DEV_TAP_WINDOWS_PRIVATE_H
+#define __PICO_DEV_TAP_WINDOWS_PRIVATE_H
+
+/* Extra defines (vnz) */
+#define TAP_WIN_COMPONENT_ID  "tap0901"
+#define TAP_WIN_MIN_MAJOR     9
+#define TAP_WIN_MIN_MINOR     9
+#define PACKAGE_NAME          "PicoTCP WinTAP"
+
+/* Extra structs */
+struct tap_reg
+{
+    const char *guid;
+    struct tap_reg *next;
+};
+
+struct panel_reg
+{
+    const char *name;
+    const char *guid;
+    struct panel_reg *next;
+};
+
+
+/*
+ * =============
+ * TAP IOCTLs
+ * =============
+ */
+
+#define TAP_WIN_CONTROL_CODE(request, method) \
+    CTL_CODE (FILE_DEVICE_UNKNOWN, request, method, FILE_ANY_ACCESS)
+
+/* Present in 8.1 */
+
+#define TAP_WIN_IOCTL_GET_MAC               TAP_WIN_CONTROL_CODE (1, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_GET_VERSION           TAP_WIN_CONTROL_CODE (2, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_GET_MTU               TAP_WIN_CONTROL_CODE (3, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_GET_INFO              TAP_WIN_CONTROL_CODE (4, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_CONFIG_POINT_TO_POINT TAP_WIN_CONTROL_CODE (5, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_SET_MEDIA_STATUS      TAP_WIN_CONTROL_CODE (6, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_CONFIG_DHCP_MASQ      TAP_WIN_CONTROL_CODE (7, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_GET_LOG_LINE          TAP_WIN_CONTROL_CODE (8, METHOD_BUFFERED)
+#define TAP_WIN_IOCTL_CONFIG_DHCP_SET_OPT   TAP_WIN_CONTROL_CODE (9, METHOD_BUFFERED)
+
+/* Added in 8.2 */
+
+/* obsoletes TAP_WIN_IOCTL_CONFIG_POINT_TO_POINT */
+#define TAP_WIN_IOCTL_CONFIG_TUN            TAP_WIN_CONTROL_CODE (10, METHOD_BUFFERED)
+
+/*
+ * =================
+ * Registry keys
+ * =================
+ */
+
+#define ADAPTER_KEY "SYSTEM\\CurrentControlSet\\Control\\Class\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
+
+#define NETWORK_CONNECTIONS_KEY "SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}"
+
+/*
+ * ======================
+ * Filesystem prefixes
+ * ======================
+ */
+
+#define USERMODEDEVICEDIR "\\\\.\\Global\\"
+#define SYSDEVICEDIR      "\\Device\\"
+#define USERDEVICEDIR     "\\DosDevices\\Global\\"
+#define TAP_WIN_SUFFIX    ".tap"
+
+#endif
diff -ruN picotcp/build/include/pico_dev_tun.h stack/picotcp/build/include/pico_dev_tun.h
--- picotcp/build/include/pico_dev_tun.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_tun.h	2023-12-29 11:06:34.336366800 +0100
@@ -0,0 +1,15 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_TUN
+#define INCLUDE_PICO_TUN
+#include "pico_config.h"
+#include "pico_device.h"
+
+void pico_tun_destroy(struct pico_device *tun);
+struct pico_device *pico_tun_create(char *name);
+
+#endif
+
diff -ruN picotcp/build/include/pico_dev_vde.h stack/picotcp/build/include/pico_dev_vde.h
--- picotcp/build/include/pico_dev_vde.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dev_vde.h	2023-12-29 11:06:34.338350700 +0100
@@ -0,0 +1,18 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_VDE
+#define INCLUDE_PICO_VDE
+#include "pico_config.h"
+#include "pico_device.h"
+#include <libvdeplug.h>
+
+void pico_vde_destroy(struct pico_device *vde);
+struct pico_device *pico_vde_create(char *sock, char *name, uint8_t *mac);
+void pico_vde_set_packetloss(struct pico_device *dev, uint32_t in_pct, uint32_t out_pct);
+
+#endif
+
diff -ruN picotcp/build/include/pico_device.h stack/picotcp/build/include/pico_device.h
--- picotcp/build/include/pico_device.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_device.h	2023-12-29 11:06:34.270895100 +0100
@@ -0,0 +1,55 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_DEVICE
+#define INCLUDE_PICO_DEVICE
+#include "pico_queue.h"
+#include "pico_frame.h"
+#include "pico_addressing.h"
+#include "pico_tree.h"
+extern struct pico_tree Device_tree;
+#include "pico_ipv6_nd.h"
+#define MAX_DEVICE_NAME 16
+
+
+struct pico_ethdev {
+    struct pico_eth mac;
+};
+
+struct pico_device {
+    char name[MAX_DEVICE_NAME];
+    uint32_t hash;
+    uint32_t overhead;
+    uint32_t mtu;
+    struct pico_ethdev *eth; /* Null if non-ethernet */
+    enum pico_ll_mode mode;
+    struct pico_queue *q_in;
+    struct pico_queue *q_out;
+    int (*link_state)(struct pico_device *self);
+    int (*send)(struct pico_device *self, void *buf, int len); /* Send function. Return 0 if busy */
+    int (*poll)(struct pico_device *self, int loop_score);
+    void (*destroy)(struct pico_device *self);
+    int (*dsr)(struct pico_device *self, int loop_score);
+    int __serving_interrupt;
+    /* used to signal the upper layer the number of events arrived since the last processing */
+    volatile int eventCnt;
+  #ifdef PICO_SUPPORT_IPV6
+    struct pico_nd_hostvars hostvars;
+  #endif
+};
+
+
+int pico_device_init(struct pico_device *dev, const char *name, const uint8_t *mac);
+void pico_device_destroy(struct pico_device *dev);
+int pico_devices_loop(int loop_score, int direction);
+struct pico_device*pico_get_device(const char*name);
+int32_t pico_device_broadcast(struct pico_frame *f);
+int pico_device_link_state(struct pico_device *dev);
+int pico_device_ipv6_random_ll(struct pico_device *dev);
+#ifdef PICO_SUPPORT_IPV6
+struct pico_ipv6_link *pico_ipv6_link_add_local(struct pico_device *dev, const struct pico_ip6 *prefix);
+#endif
+
+#endif
diff -ruN picotcp/build/include/pico_dhcp_client.h stack/picotcp/build/include/pico_dhcp_client.h
--- picotcp/build/include/pico_dhcp_client.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dhcp_client.h	2023-12-29 11:06:34.339673800 +0100
@@ -0,0 +1,32 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_DHCP_CLIENT
+#define INCLUDE_PICO_DHCP_CLIENT
+#include "pico_defines.h"
+#ifdef PICO_SUPPORT_UDP
+#include "pico_dhcp_common.h"
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+
+int pico_dhcp_initiate_negotiation(struct pico_device *device, void (*callback)(void*cli, int code), uint32_t *xid);
+void *pico_dhcp_get_identifier(uint32_t xid);
+struct pico_ip4 pico_dhcp_get_address(void *cli);
+struct pico_ip4 pico_dhcp_get_gateway(void *cli);
+struct pico_ip4 pico_dhcp_get_netmask(void *cli);
+struct pico_ip4 pico_dhcp_get_nameserver(void*cli, int index);
+int pico_dhcp_client_abort(uint32_t xid);
+char *pico_dhcp_get_hostname(void);
+char *pico_dhcp_get_domain(void);
+
+/* possible codes for the callback */
+#define PICO_DHCP_SUCCESS 0
+#define PICO_DHCP_ERROR   1
+#define PICO_DHCP_RESET   2
+
+#endif
+#endif
diff -ruN picotcp/build/include/pico_dhcp_common.h stack/picotcp/build/include/pico_dhcp_common.h
--- picotcp/build/include/pico_dhcp_common.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dhcp_common.h	2023-12-29 11:06:34.341658700 +0100
@@ -0,0 +1,191 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_DHCP_COMMON
+#define INCLUDE_PICO_DHCP_COMMON
+#include "pico_config.h"
+#include "pico_addressing.h"
+
+#define PICO_DHCPD_PORT (short_be(67))
+#define PICO_DHCP_CLIENT_PORT (short_be(68))
+#define PICO_DHCPD_MAGIC_COOKIE (long_be(0x63825363))
+#define PICO_DHCP_HTYPE_ETH 1
+
+/* Macro to get DHCP option field */
+#define DHCP_OPT(hdr, off)              ((struct pico_dhcp_opt *)(((uint8_t *)hdr) + sizeof(struct pico_dhcp_hdr) + off))
+
+/* flags */
+#define PICO_DHCP_FLAG_BROADCAST        0x8000
+
+/* options */
+#define PICO_DHCP_OPT_PAD               0x00
+#define PICO_DHCP_OPT_NETMASK           0x01
+#define PICO_DHCP_OPT_TIME              0x02
+#define PICO_DHCP_OPT_ROUTER            0x03
+#define PICO_DHCP_OPT_DNS               0x06
+#define PICO_DHCP_OPT_HOSTNAME          0x0c
+#define PICO_DHCP_OPT_DOMAINNAME        0x0f
+#define PICO_DHCP_OPT_MTU               0x1a
+#define PICO_DHCP_OPT_BROADCAST         0x1c
+#define PICO_DHCP_OPT_NETBIOSNS         0x2c
+#define PICO_DHCP_OPT_NETBIOSSCOPE      0x2f
+#define PICO_DHCP_OPT_REQIP             0x32
+#define PICO_DHCP_OPT_LEASETIME         0x33
+#define PICO_DHCP_OPT_OPTOVERLOAD       0x34
+#define PICO_DHCP_OPT_MSGTYPE           0x35
+#define PICO_DHCP_OPT_SERVERID          0x36
+#define PICO_DHCP_OPT_PARAMLIST         0x37
+#define PICO_DHCP_OPT_MESSAGE           0x38
+#define PICO_DHCP_OPT_MAXMSGSIZE        0x39
+#define PICO_DHCP_OPT_RENEWALTIME       0x3a
+#define PICO_DHCP_OPT_REBINDINGTIME     0x3b
+#define PICO_DHCP_OPT_VENDORID          0x3c
+#define PICO_DHCP_OPT_CLIENTID          0x3d
+#define PICO_DHCP_OPT_DOMAINSEARCH      0x77
+#define PICO_DHCP_OPT_STATICROUTE       0x79
+#define PICO_DHCP_OPT_END               0xFF
+
+/* options len */
+#define PICO_DHCP_OPTLEN_HDR            2 /* account for code and len field */
+#define PICO_DHCP_OPTLEN_NETMASK        6
+#define PICO_DHCP_OPTLEN_ROUTER         6
+#define PICO_DHCP_OPTLEN_DNS            6
+#define PICO_DHCP_OPTLEN_BROADCAST      6
+#define PICO_DHCP_OPTLEN_REQIP          6
+#define PICO_DHCP_OPTLEN_LEASETIME      6
+#define PICO_DHCP_OPTLEN_OPTOVERLOAD    3
+#define PICO_DHCP_OPTLEN_MSGTYPE        3
+#define PICO_DHCP_OPTLEN_SERVERID       6
+#define PICO_DHCP_OPTLEN_PARAMLIST      9 /* PicoTCP specific */
+#define PICO_DHCP_OPTLEN_MAXMSGSIZE     4
+#define PICO_DHCP_OPTLEN_RENEWALTIME    6
+#define PICO_DHCP_OPTLEN_REBINDINGTIME  6
+#define PICO_DHCP_OPTLEN_END            1
+
+/* op codes */
+#define PICO_DHCP_OP_REQUEST            1
+#define PICO_DHCP_OP_REPLY              2
+
+/* rfc message types */
+#define PICO_DHCP_MSG_DISCOVER          1
+#define PICO_DHCP_MSG_OFFER             2
+#define PICO_DHCP_MSG_REQUEST           3
+#define PICO_DHCP_MSG_DECLINE           4
+#define PICO_DHCP_MSG_ACK               5
+#define PICO_DHCP_MSG_NAK               6
+#define PICO_DHCP_MSG_RELEASE           7
+#define PICO_DHCP_MSG_INFORM            8
+
+/* custom message types */
+#define PICO_DHCP_EVENT_T1              9
+#define PICO_DHCP_EVENT_T2              10
+#define PICO_DHCP_EVENT_LEASE           11
+#define PICO_DHCP_EVENT_RETRANSMIT      12
+#define PICO_DHCP_EVENT_NONE            0xff
+
+PACKED_STRUCT_DEF pico_dhcp_hdr
+{
+    uint8_t op;
+    uint8_t htype;
+    uint8_t hlen;
+    uint8_t hops; /* zero */
+    uint32_t xid; /* store this in the request */
+    uint16_t secs; /* ignore */
+    uint16_t flags;
+    uint32_t ciaddr; /* client address - if asking for renewal */
+    uint32_t yiaddr; /* your address (client) */
+    uint32_t siaddr; /* dhcp offered address */
+    uint32_t giaddr; /* relay agent, bootp. */
+    uint8_t hwaddr[6];
+    uint8_t hwaddr_padding[10];
+    char hostname[64];
+    char bootp_filename[128];
+    uint32_t dhcp_magic;
+};
+
+PACKED_STRUCT_DEF pico_dhcp_opt
+{
+    uint8_t code;
+    uint8_t len;
+    PACKED_UNION_DEF dhcp_opt_ext_u {
+        PEDANTIC_STRUCT_DEF netmask_s {
+            struct pico_ip4 ip;
+        } netmask;
+        PEDANTIC_STRUCT_DEF router_s {
+            struct pico_ip4 ip;
+        } router;
+        PEDANTIC_STRUCT_DEF dns_s {
+            struct pico_ip4 ip;
+        } dns1;
+        struct dns_s dns2;
+        PEDANTIC_STRUCT_DEF broadcast_s {
+            struct pico_ip4 ip;
+        } broadcast;
+        PEDANTIC_STRUCT_DEF req_ip_s {
+            struct pico_ip4 ip;
+        } req_ip;
+        PEDANTIC_STRUCT_DEF lease_time_s {
+            uint32_t time;
+        } lease_time;
+        PEDANTIC_STRUCT_DEF opt_overload_s {
+            uint8_t value;
+        } opt_overload;
+        PEDANTIC_STRUCT_DEF tftp_server_s {
+            char name[1];
+        } tftp_server;
+        PEDANTIC_STRUCT_DEF bootfile_s {
+            char name[1];
+        } bootfile;
+        PEDANTIC_STRUCT_DEF msg_type_s {
+            uint8_t type;
+        } msg_type;
+        PEDANTIC_STRUCT_DEF server_id_s {
+            struct pico_ip4 ip;
+        } server_id;
+        PEDANTIC_STRUCT_DEF param_list_s {
+            uint8_t code[1];
+        } param_list;
+        PEDANTIC_STRUCT_DEF message_s {
+            char error[1];
+        } message;
+        PEDANTIC_STRUCT_DEF max_msg_size_s {
+            uint16_t size;
+        } max_msg_size;
+        PEDANTIC_STRUCT_DEF renewal_time_s {
+            uint32_t time;
+        } renewal_time;
+        PEDANTIC_STRUCT_DEF rebinding_time_s {
+            uint32_t time;
+        } rebinding_time;
+        PEDANTIC_STRUCT_DEF vendor_id_s {
+            uint8_t id[1];
+        } vendor_id;
+        PEDANTIC_STRUCT_DEF client_id_s {
+            uint8_t id[1];
+        } client_id;
+        PEDANTIC_STRUCT_DEF text_s {
+            char txt[1];
+        } string;
+    } ext;
+};
+
+uint8_t dhcp_get_next_option(uint8_t *begin, uint8_t *data, int *len, uint8_t **nextopt);
+struct pico_dhcp_opt *pico_dhcp_next_option(struct pico_dhcp_opt **ptr);
+uint8_t pico_dhcp_are_options_valid(void *ptr, int32_t len);
+
+uint8_t pico_dhcp_opt_netmask(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_router(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_dns(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_broadcast(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_reqip(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_leasetime(void *ptr, uint32_t time);
+uint8_t pico_dhcp_opt_msgtype(void *ptr, uint8_t type);
+uint8_t pico_dhcp_opt_serverid(void *ptr, struct pico_ip4 *ip);
+uint8_t pico_dhcp_opt_paramlist(void *ptr);
+uint8_t pico_dhcp_opt_maxmsgsize(void *ptr, uint16_t size);
+uint8_t pico_dhcp_opt_end(void *ptr);
+#endif
diff -ruN picotcp/build/include/pico_dhcp_server.h stack/picotcp/build/include/pico_dhcp_server.h
--- picotcp/build/include/pico_dhcp_server.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dhcp_server.h	2023-12-29 11:06:34.343641800 +0100
@@ -0,0 +1,34 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_DHCP_SERVER
+#define INCLUDE_PICO_DHCP_SERVER
+#include "pico_defines.h"
+#ifdef PICO_SUPPORT_UDP
+
+#include "pico_dhcp_common.h"
+#include "pico_addressing.h"
+
+struct pico_dhcp_server_setting
+{
+    uint32_t pool_start;
+    uint32_t pool_next;
+    uint32_t pool_end;
+    uint32_t lease_time;
+    struct pico_device *dev;
+    struct pico_socket *s;
+    struct pico_ip4 server_ip;
+    struct pico_ip4 netmask;
+    uint8_t flags; /* unused atm */
+};
+
+/* required field: IP address of the interface to serve, only IPs of this network will be served. */
+int pico_dhcp_server_initiate(struct pico_dhcp_server_setting *dhcps);
+
+/* To destroy an existing DHCP server configuration, running on a given interface */
+int pico_dhcp_server_destroy(struct pico_device *dev);
+
+#endif /* _INCLUDE_PICO_DHCP_SERVER */
+#endif
diff -ruN picotcp/build/include/pico_dns_client.h stack/picotcp/build/include/pico_dns_client.h
--- picotcp/build/include/pico_dns_client.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dns_client.h	2023-12-29 11:06:34.344964100 +0100
@@ -0,0 +1,50 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012 TASS Belgium NV. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Authors: Kristof Roelants
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_DNS_CLIENT
+#define INCLUDE_PICO_DNS_CLIENT
+
+#define PICO_DNS_NS_DEL 0
+#define PICO_DNS_NS_ADD 1
+#include "pico_config.h"
+
+/* Compression values */
+#define PICO_DNS_LABEL 0
+#define PICO_DNS_POINTER 3
+
+/* Label len */
+#define PICO_DNS_LABEL_INITIAL 1u
+#define PICO_DNS_LABEL_ROOT 1
+
+/* TTL values */
+#define PICO_DNS_MAX_TTL 604800 /* one week */
+
+/* Len of an IPv4 address string */
+#define PICO_DNS_IPV4_ADDR_LEN 16
+#define PICO_DNS_IPV6_ADDR_LEN 54
+
+/* Default nameservers + port */
+#define PICO_DNS_NS_DEFAULT "208.67.222.222"
+#define PICO_DNS_NS_PORT 53
+
+/* RDLENGTH for A and AAAA RR's */
+#define PICO_DNS_RR_A_RDLENGTH 4
+#define PICO_DNS_RR_AAAA_RDLENGTH 16
+
+int pico_dns_client_init(void);
+/* flag is PICO_DNS_NS_DEL or PICO_DNS_NS_ADD */
+int pico_dns_client_nameserver(struct pico_ip4 *ns, uint8_t flag);
+int pico_dns_client_getaddr(const char *url, void (*callback)(char *ip, void *arg), void *arg);
+int pico_dns_client_getname(const char *ip, void (*callback)(char *url, void *arg), void *arg);
+#ifdef PICO_SUPPORT_IPV6
+int pico_dns_client_getaddr6(const char *url, void (*callback)(char *, void *), void *arg);
+int pico_dns_client_getname6(const char *url, void (*callback)(char *, void *), void *arg);
+#endif
+
+#endif /* _INCLUDE_PICO_DNS_CLIENT */
diff -ruN picotcp/build/include/pico_dns_common.h stack/picotcp/build/include/pico_dns_common.h
--- picotcp/build/include/pico_dns_common.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dns_common.h	2023-12-29 11:06:34.346948200 +0100
@@ -0,0 +1,528 @@
+
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012 TASS Belgium NV. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+   .
+   Authors: Toon Stegen, Jelle De Vleeschouwer
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_DNS_COMMON
+#define INCLUDE_PICO_DNS_COMMON
+
+#include "pico_config.h"
+#include "pico_tree.h"
+
+/* TYPE values */
+#define PICO_DNS_TYPE_A 1
+#define PICO_DNS_TYPE_CNAME 5
+#define PICO_DNS_TYPE_PTR 12
+#define PICO_DNS_TYPE_TXT 16
+#define PICO_DNS_TYPE_AAAA 28
+#define PICO_DNS_TYPE_SRV 33
+#define PICO_DNS_TYPE_NSEC 47
+#define PICO_DNS_TYPE_ANY 255
+
+/* CLASS values */
+#define PICO_DNS_CLASS_IN 1
+
+/* FLAG values */
+#define PICO_DNS_QR_QUERY 0
+#define PICO_DNS_QR_RESPONSE 1
+#define PICO_DNS_OPCODE_QUERY 0
+#define PICO_DNS_OPCODE_IQUERY 1
+#define PICO_DNS_OPCODE_STATUS 2
+#define PICO_DNS_AA_NO_AUTHORITY 0
+#define PICO_DNS_AA_IS_AUTHORITY 1
+#define PICO_DNS_TC_NO_TRUNCATION 0
+#define PICO_DNS_TC_IS_TRUNCATED 1
+#define PICO_DNS_RD_NO_DESIRE 0
+#define PICO_DNS_RD_IS_DESIRED 1
+#define PICO_DNS_RA_NO_SUPPORT 0
+#define PICO_DNS_RA_IS_SUPPORTED 1
+#define PICO_DNS_RCODE_NO_ERROR 0
+#define PICO_DNS_RCODE_EFORMAT 1
+#define PICO_DNS_RCODE_ESERVER 2
+#define PICO_DNS_RCODE_ENAME 3
+#define PICO_DNS_RCODE_ENOIMP 4
+#define PICO_DNS_RCODE_EREFUSED 5
+
+#define PICO_ARPA_IPV4_SUFFIX ".in-addr.arpa"
+
+#ifdef PICO_SUPPORT_IPV6
+#define STRLEN_PTR_IP6 63
+#define PICO_ARPA_IPV6_SUFFIX ".IP6.ARPA"
+#endif
+
+/* Used in pico_dns_rdata_cmp  */
+#define PICO_DNS_CASE_SENSITIVE 0x00u
+#define PICO_DNS_CASE_INSENSITIVE 0x01u
+
+#define PICO_DNS_NAMEBUF_SIZE (256)
+
+enum pico_dns_arpa
+{
+    PICO_DNS_ARPA4,
+    PICO_DNS_ARPA6,
+    PICO_DNS_NO_ARPA,
+};
+
+/* flags split in 2x uint8 due to endianness */
+PACKED_STRUCT_DEF pico_dns_header
+{
+    uint16_t id;        /* Packet id */
+    uint8_t rd : 1;     /* Recursion Desired */
+    uint8_t tc : 1;     /* TrunCation */
+    uint8_t aa : 1;     /* Authoritative Answer */
+    uint8_t opcode : 4; /* Opcode */
+    uint8_t qr : 1;     /* Query/Response */
+    uint8_t rcode : 4;  /* Response code */
+    uint8_t z : 3;      /* Zero */
+    uint8_t ra : 1;     /* Recursion Available */
+    uint16_t qdcount;   /* Question count */
+    uint16_t ancount;   /* Answer count */
+    uint16_t nscount;   /* Authority count */
+    uint16_t arcount;   /* Additional count */
+};
+typedef struct pico_dns_header pico_dns_packet;
+
+/* Question fixed-sized fields */
+PACKED_STRUCT_DEF pico_dns_question_suffix
+{
+    uint16_t qtype;
+    uint16_t qclass;
+};
+
+/* Resource record fixed-sized fields */
+PACKED_STRUCT_DEF pico_dns_record_suffix
+{
+    uint16_t rtype;
+    uint16_t rclass;
+    uint32_t rttl;
+    uint16_t rdlength;
+};
+
+/* DNS QUESTION */
+struct pico_dns_question
+{
+    char *qname;
+    struct pico_dns_question_suffix *qsuffix;
+    uint16_t qname_length;
+    uint8_t proto;
+};
+
+/* DNS RECORD */
+struct pico_dns_record
+{
+    char *rname;
+    struct pico_dns_record_suffix *rsuffix;
+    uint8_t *rdata;
+    uint16_t rname_length;
+};
+
+/* MARK: v NAME & IP FUNCTIONS */
+
+/* ****************************************************************************
+ *  Checks if the DNS name doesn't exceed 256 bytes including zero-byte.
+ *
+ *  @param namelen Length of the DNS name-string including zero-byte
+ *  @return 0 when the length is correct
+ * ****************************************************************************/
+int
+pico_dns_check_namelen( uint16_t namelen );
+
+/* ****************************************************************************
+ *  Returns the length of a name in a DNS-packet as if DNS name compression
+ *  would be applied to the packet. If there's no compression present this
+ *	returns the strlen. If there's compression present this returns the length
+ *	until the compression-pointer + 1.
+ *
+ *  @param name Compressed name you want the calculate the strlen from
+ *  @return Returns strlen of a compressed name, takes the first byte of compr-
+ *			ession pointer into account but not the second byte, which acts
+ *			like a trailing zero-byte.
+ * ****************************************************************************/
+uint16_t
+pico_dns_namelen_comp( char *name );
+
+/* ****************************************************************************
+ *  Returns the uncompressed name in DNS name format when DNS name compression
+ *  is applied to the packet-buffer.
+ *
+ *  @param name   Compressed name, should be in the bounds of the actual packet
+ *  @param packet Packet that contains the compressed name
+ *  @return Returns the decompressed name, NULL on failure.
+ * ****************************************************************************/
+char *
+pico_dns_decompress_name( char *name, pico_dns_packet *packet );
+
+/* ****************************************************************************
+ *  Converts a DNS name in DNS name format to a name in URL format. Provides
+ *  space for the name in URL format as well. PICO_FREE() should be called on
+ *  the returned string buffer that contains the name in URL format.
+ *
+ *  @param qname DNS name in DNS name format to convert
+ *  @return Returns a pointer to a string-buffer with the URL name on success.
+ * ****************************************************************************/
+char *
+pico_dns_qname_to_url( const char *qname );
+
+/* ****************************************************************************
+ *  Converts a DNS name in URL format to name in DNS name format. Provides
+ *  space for the DNS name as well. PICO_FREE() should be called on the returned
+ *  string buffer that contains the DNS name.
+ *
+ *  @param url DNS name in URL format to convert
+ *  @return Returns a pointer to a string-buffer with the DNS name on success.
+ * ****************************************************************************/
+char *
+pico_dns_url_to_qname( const char *url );
+
+/* ****************************************************************************
+ *  @param url String-buffer
+ *  @return Length of string-buffer in an uint16_t
+ * ****************************************************************************/
+uint16_t
+pico_dns_strlen( const char *url );
+
+/* ****************************************************************************
+ *  Replaces .'s in a DNS name in URL format by the label lengths. So it
+ *  actually converts a name in URL format to a name in DNS name format.
+ *  f.e. "*www.google.be" => "3www6google2be0"
+ *
+ *  @param url    Location to buffer with name in URL format. The URL needs to
+ *                be +1 byte offset in the actual buffer. Size is should be
+ *                strlen(url) + 2.
+ *  @param maxlen Maximum length of buffer so it doesn't cause a buffer overflow
+ *  @return 0 on success, something else on failure.
+ * ****************************************************************************/
+int pico_dns_name_to_dns_notation( char *url, uint16_t maxlen );
+
+/* ****************************************************************************
+ *  Replaces the label lengths in a DNS-name by .'s. So it actually converts a
+ *  name in DNS format to a name in URL format.
+ *  f.e. 3www6google2be0 => .www.google.be
+ *
+ *  @param ptr    Location to buffer with name in DNS name format
+ *  @param maxlen Maximum length of buffer so it doesn't cause a buffer overflow
+ *  @return 0 on success, something else on failure.
+ * ****************************************************************************/
+int pico_dns_notation_to_name( char *ptr, uint16_t maxlen );
+
+/* ****************************************************************************
+ *  Determines the length of the first label of a DNS name in URL-format
+ *
+ *  @param url DNS name in URL-format
+ *  @return Length of the first label of DNS name in URL-format
+ * ****************************************************************************/
+uint16_t
+pico_dns_first_label_length( const char *url );
+
+/* ****************************************************************************
+ *  Mirrors a dotted IPv4-address string.
+ *	f.e. 192.168.0.1 => 1.0.168.192
+ *
+ *  @param ptr
+ *  @return 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_dns_mirror_addr( char *ptr );
+
+/* ****************************************************************************
+ *  Convert an IPv6-address in string-format to a IPv6-address in nibble-format.
+ *	Doesn't add a IPv6 ARPA-suffix though.
+ *
+ *  @param ip  IPv6-address stored as a string
+ *  @param dst Destination to store IPv6-address in nibble-format
+ * ****************************************************************************/
+void
+pico_dns_ipv6_set_ptr( const char *ip, char *dst );
+
+/* MARK: QUESTION FUNCTIONS */
+
+/* ****************************************************************************
+ *  Deletes a single DNS Question.
+ *
+ *  @param question Void-pointer to DNS Question. Can be used with pico_tree_-
+ *					destroy.
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_dns_question_delete( void **question);
+
+/* ****************************************************************************
+ *  Fills in the DNS question suffix-fields with the correct values.
+ *
+ *  todo: Update pico_dns_client to make the same mechanism possible as with
+ *        filling DNS Resource Record-suffixes. This function shouldn't be an
+ *		  API-function.
+ *
+ *  @param suf    Pointer to the suffix member of the DNS question.
+ *  @param qtype  DNS type of the DNS question to be.
+ *  @param qclass DNS class of the DNS question to be.
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_dns_question_fill_suffix( struct pico_dns_question_suffix *suf,
+                               uint16_t qtype,
+                               uint16_t qclass );
+
+/* ****************************************************************************
+ *  Creates a standalone DNS Question with a given name and type.
+ *
+ *  @param url     DNS question name in URL format. Will be converted to DNS
+ *				   name notation format.
+ *  @param len     Will be filled with the total length of the DNS question.
+ *  @param proto   Protocol for which you want to create a question. Can be
+ *				   either PICO_PROTO_IPV4 or PICO_PROTO_IPV6.
+ *  @param qtype   DNS type of the question to be.
+ *  @param qclass  DNS class of the question to be.
+ *  @param reverse When this is true, a reverse resolution name will be gene-
+ *				   from the URL
+ *  @return Returns pointer to the created DNS Question on success, NULL on
+ *			failure.
+ * ****************************************************************************/
+struct pico_dns_question *
+pico_dns_question_create( const char *url,
+                          uint16_t *len,
+                          uint8_t proto,
+                          uint16_t qtype,
+                          uint16_t qclass,
+                          uint8_t reverse );
+
+/* ****************************************************************************
+ *  Decompresses the name of a single DNS question.
+ *
+ *  @param question Question you want to decompress the name of
+ *  @param packet   Packet in which the DNS question is contained.
+ *  @return Pointer to original name of the DNS question before decompressing.
+ * ****************************************************************************/
+char *
+pico_dns_question_decompress( struct pico_dns_question *question,
+                              pico_dns_packet *packet );
+
+/* MARK: RESOURCE RECORD FUNCTIONS */
+
+/* ****************************************************************************
+ *  Deletes a single DNS resource record.
+ *
+ *  @param record Void-pointer to DNS record. Can be used with pico_tree_destroy
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_dns_record_delete( void **record );
+
+/* ****************************************************************************
+ *  Just makes a hardcopy from a single DNS Resource Record
+ *
+ *  @param record DNS record you want to copy
+ *  @return Pointer to copy of DNS record.
+ * ****************************************************************************/
+struct pico_dns_record *
+pico_dns_record_copy( struct pico_dns_record *record );
+
+/* ****************************************************************************
+ *  Create a standalone DNS Resource Record with given name, type and data.
+ *
+ *  @param url     DNS rrecord name in URL format. Will be converted to DNS
+ *                 name notation format.
+ *  @param _rdata  Memory buffer with data to insert in the resource record. If
+ *				   data of record should contain a DNS name, the name in the
+ *				   databuffer needs to be in URL-format.
+ *  @param datalen The exact length in bytes of the _rdata-buffer. If data of
+ *				   record should contain a DNS name, datalen needs to be
+ *				   pico_dns_strlen(_rdata).
+ *  @param len     Will be filled with the total length of the DNS rrecord.
+ *  @param rtype   DNS type of the resource record to be.
+ *  @param rclass  DNS class of the resource record to be.
+ *  @param rttl    DNS ttl of the resource record to be.
+ *  @return Returns pointer to the created DNS Resource Record
+ * ****************************************************************************/
+struct pico_dns_record *
+pico_dns_record_create( const char *url,
+                        void *_rdata,
+                        uint16_t datalen,
+                        uint16_t *len,
+                        uint16_t rtype,
+                        uint16_t rclass,
+                        uint32_t rttl );
+
+/* ****************************************************************************
+ *  Decompresses the name of single DNS record.
+ *
+ *  @param record DNS record to decompress the name of.
+ *  @param packet Packet in which is DNS record is present
+ *  @return Pointer to original name of the DNS record before decompressing.
+ * ****************************************************************************/
+char *
+pico_dns_record_decompress( struct pico_dns_record *record,
+                            pico_dns_packet *packet );
+
+/* MARK: COMPARING */
+
+/* ****************************************************************************
+ *  Compares two databuffers against each other.
+ *
+ *  @param a          1st Memory buffer to compare
+ *  @param b          2nd Memory buffer to compare
+ *  @param rdlength_a Length of 1st memory buffer
+ *  @param rdlength_b Length of 2nd memory buffer
+ *  @param caseinsensitive Whether or not the bytes are compared
+ *                         case-insensitive. Should be either
+ *                         PICO_DNS_CASE_SENSITIVE or PICO_DNS_CASE_INSENSITIVE
+ *  @return 0 when the buffers are equal, returns difference when they're not.
+ * ****************************************************************************/
+int
+pico_dns_rdata_cmp( uint8_t *a, uint8_t *b,
+                    uint16_t rdlength_a, uint16_t rdlength_b, uint8_t caseinsensitive );
+
+/* ****************************************************************************
+ *  Compares 2 DNS questions
+ *
+ *  @param qa DNS question A as a void-pointer (for pico_tree)
+ *  @param qb DNS question A as a void-pointer (for pico_tree)
+ *  @return 0 when questions are equal, returns difference when they're not.
+ * ****************************************************************************/
+int
+pico_dns_question_cmp( void *qa,
+                       void *qb );
+
+/* ****************************************************************************
+ *  Compares 2 DNS records by type and name only
+ *
+ *  @param ra DNS record A as a void-pointer (for pico_tree)
+ *  @param rb DNS record B as a void-pointer (for pico_tree)
+ *  @return 0 when name and type of records are equal, returns difference when
+ *			they're not.
+ * ****************************************************************************/
+int
+pico_dns_record_cmp_name_type( void *ra,
+                               void *rb );
+
+/* ****************************************************************************
+ *  Compares 2 DNS records by type, name AND rdata for a truly unique result
+ *
+ *  @param ra DNS record A as a void-pointer (for pico_tree)
+ *  @param rb DNS record B as a void-pointer (for pico_tree)
+ *  @return 0 when records are equal, returns difference when they're not
+ * ****************************************************************************/
+int
+pico_dns_record_cmp( void *ra,
+                     void *rb );
+
+/* MARK: PICO_TREE */
+
+/* ****************************************************************************
+ *  Erases a pico_tree entirely.
+ *
+ *  @param tree        Pointer to a pico_tree-instance
+ *  @param node_delete Helper-function for type-specific deleting.
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_tree_destroy( struct pico_tree *tree, int (*node_delete)(void **));
+
+/* ****************************************************************************
+ *  Determines the amount of nodes in a pico_tree
+ *
+ *  @param tree Pointer to pico_tree-instance
+ *  @return Amount of items in the tree.
+ * ****************************************************************************/
+uint16_t
+pico_tree_count( struct pico_tree *tree );
+
+/* ****************************************************************************
+ *  Definition of DNS question tree
+ * ****************************************************************************/
+typedef struct pico_tree pico_dns_qtree;
+#define PICO_DNS_QTREE_DECLARE(name) \
+    pico_dns_qtree (name) = {&LEAF, pico_dns_question_cmp}
+#define PICO_DNS_QTREE_DESTROY(qtree) \
+    pico_tree_destroy(qtree, pico_dns_question_delete)
+
+/* ****************************************************************************
+ *  Deletes all the questions with given DNS name from a pico_tree
+ *
+ *  @param qtree Pointer to pico_tree-instance which contains DNS questions
+ *  @param name  Name of the questions you want to delete
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_dns_qtree_del_name( struct pico_tree *qtree,
+                         const char *name );
+
+/* ****************************************************************************
+ *  Checks whether a question with given name is in the tree or not.
+ *
+ *  @param qtree Pointer to pico_tree-instance which contains DNS questions
+ *  @param name  Name you want to check for
+ *  @return 1 when the name is present in the qtree, 0 when it's not.
+ * ****************************************************************************/
+int
+pico_dns_qtree_find_name( struct pico_tree *qtree,
+                          const char *name );
+
+/* ****************************************************************************
+ *  Definition of DNS record tree
+ * ****************************************************************************/
+typedef struct pico_tree pico_dns_rtree;
+#define PICO_DNS_RTREE_DECLARE(name) \
+    pico_dns_rtree (name) = {&LEAF, pico_dns_record_cmp}
+#define PICO_DNS_RTREE_DESTROY(rtree) \
+    pico_tree_destroy((rtree), pico_dns_record_delete)
+
+/* MARK: DNS PACKET FUNCTIONS */
+
+/* ****************************************************************************
+ *  Fills the header section of a DNS packet with the correct flags and section
+ *  -counts.
+ *
+ *  @param hdr     Header to fill in.
+ *  @param qdcount Amount of questions added to the packet
+ *  @param ancount Amount of answer records added to the packet
+ *  @param nscount Amount of authority records added to the packet
+ *  @param arcount Amount of additional records added to the packet
+ * ****************************************************************************/
+void
+pico_dns_fill_packet_header( struct pico_dns_header *hdr,
+                             uint16_t qdcount,
+                             uint16_t ancount,
+                             uint16_t authcount,
+                             uint16_t addcount );
+
+/* ****************************************************************************
+ *  Creates a DNS Query packet with given question and resource records to put
+ *  the Resource Record Sections. If a NULL-pointer is provided for a certain
+ *  tree, no records will be added to that particular section of the packet.
+ *
+ *  @param qtree  DNS Questions to put in the Question Section
+ *  @param antree DNS Records to put in the Answer Section
+ *  @param nstree DNS Records to put in the Authority Section
+ *  @param artree DNS Records to put in the Additional Section
+ *  @param len    Will get filled with the entire size of the packet
+ *  @return Pointer to created DNS packet
+ * ****************************************************************************/
+pico_dns_packet *
+pico_dns_query_create( struct pico_tree *qtree,
+                       struct pico_tree *antree,
+                       struct pico_tree *nstree,
+                       struct pico_tree *artree,
+                       uint16_t *len );
+
+/* ****************************************************************************
+ *  Creates a DNS Answer packet with given resource records to put in the
+ *  Resource Record Sections. If a NULL-pointer is provided for a certain tree,
+ *  no records will be added to that particular section of the packet.
+ *
+ *  @param antree DNS Records to put in the Answer Section
+ *  @param nstree DNS Records to put in the Authority Section
+ *  @param artree DNS Records to put in the Additional Section
+ *  @param len    Will get filled with the entire size of the packet
+ *  @return Pointer to created DNS packet.
+ * ****************************************************************************/
+pico_dns_packet *
+pico_dns_answer_create( struct pico_tree *antree,
+                        struct pico_tree *nstree,
+                        struct pico_tree *artree,
+                        uint16_t *len );
+
+#endif /* _INCLUDE_PICO_DNS_COMMON */
diff -ruN picotcp/build/include/pico_dns_sd.h stack/picotcp/build/include/pico_dns_sd.h
--- picotcp/build/include/pico_dns_sd.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_dns_sd.h	2023-12-29 11:06:34.348270700 +0100
@@ -0,0 +1,91 @@
+/* ****************************************************************************
+ *  PicoTCP. Copyright (c) 2014 TASS Belgium NV. Some rights reserved.
+ *  See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *  .
+ *  Author: Jelle De Vleeschouwer
+ * ****************************************************************************/
+#ifndef INCLUDE_PICO_DNS_SD
+#define INCLUDE_PICO_DNS_SD
+
+#include "pico_mdns.h"
+
+typedef struct
+{
+    char *key;
+    char *value;
+} key_value_pair_t;
+
+typedef struct
+{
+    key_value_pair_t **pairs;
+    uint16_t count;
+} kv_vector;
+
+#define PICO_DNS_SD_KV_VECTOR_DECLARE(name) \
+    kv_vector (name) = {0}
+
+/* ****************************************************************************
+ *  Just calls pico_mdns_init in it's turn to initialise the mDNS-module.
+ *  See pico_mdns.h for description.
+ * ****************************************************************************/
+int
+pico_dns_sd_init( const char *_hostname,
+                  struct pico_ip4 address,
+                  void (*callback)(pico_mdns_rtree *,
+                                   char *,
+                                   void *),
+                  void *arg );
+
+/* ****************************************************************************
+ *  Register a DNS-SD service via Multicast DNS on the local network.
+ *
+ *  @param name     Instance Name of the service, f.e. "Printer 2nd Floor".
+ *  @param type     ServiceType of the service, f.e. "_http._tcp".
+ *  @param port     Port number on which the service runs.
+ *  @param txt_data TXT data to create TXT record with, need kv_vector-type,
+ *                  Declare such a type with PICO_DNS_SD_KV_VECTOR_DECLARE(*) &
+ *                  add key-value pairs with pico_dns_sd_kv_vector_add().
+ *  @param ttl      TTL
+ *  @param callback Callback-function to call when the service is registered.
+ *  @return
+ * ****************************************************************************/
+int
+pico_dns_sd_register_service( const char *name,
+                              const char *type,
+                              uint16_t port,
+                              kv_vector *txt_data,
+                              uint16_t ttl,
+                              void (*callback)(pico_mdns_rtree *,
+                                               char *,
+                                               void *),
+                              void *arg);
+
+/* ****************************************************************************
+ *  Does nothing for now.
+ *
+ *  @param type     Type to browse for.
+ *  @param callback Callback to call when something particular happens.
+ *  @return When the module successfully started browsing the servicetype.
+ * ****************************************************************************/
+int
+pico_dns_sd_browse_service( const char *type,
+                            void (*callback)(pico_mdns_rtree *,
+                                             char *,
+                                             void *),
+                            void *arg );
+
+/* ****************************************************************************
+ *  Add a key-value pair the a key-value pair vector.
+ *
+ *  @param vector Vector to add the pair to.
+ *  @param key    Key of the pair, cannot be NULL.
+ *  @param value  Value of the pair, can be NULL, empty ("") or filled ("qkejq")
+ *  @return Returns 0 when the pair is added successfully, something else on
+ *			failure.
+ * ****************************************************************************/
+int
+pico_dns_sd_kv_vector_add( kv_vector *vector, char *key, char *value );
+
+
+#endif /* _INCLUDE_PICO_DNS_SD */
+
diff -ruN picotcp/build/include/pico_eth.h stack/picotcp/build/include/pico_eth.h
--- picotcp/build/include/pico_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_eth.h	2023-12-29 11:06:34.272878900 +0100
@@ -0,0 +1,21 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_ETH
+#define INCLUDE_PICO_ETH
+#include "pico_addressing.h"
+#include "pico_ipv4.h"
+#include "pico_ipv6.h"
+
+
+PACKED_STRUCT_DEF pico_eth_hdr {
+    uint8_t daddr[6];
+    uint8_t saddr[6];
+    uint16_t proto;
+};
+
+#define PICO_SIZE_ETHHDR 14
+
+#endif
diff -ruN picotcp/build/include/pico_ethernet.h stack/picotcp/build/include/pico_ethernet.h
--- picotcp/build/include/pico_ethernet.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_ethernet.h	2023-12-29 11:06:34.350254700 +0100
@@ -0,0 +1,18 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Authors: Daniele Lacamera
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_ETHERNET
+#define INCLUDE_PICO_ETHERNET
+
+#include "pico_config.h"
+#include "pico_frame.h"
+
+extern struct pico_protocol pico_proto_ethernet;
+
+#endif /* INCLUDE_PICO_ETHERNET */
diff -ruN picotcp/build/include/pico_fragments.h stack/picotcp/build/include/pico_fragments.h
--- picotcp/build/include/pico_fragments.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_fragments.h	2023-12-29 11:06:34.351577600 +0100
@@ -0,0 +1,11 @@
+#ifndef PICO_FRAGMENTS_H
+#define PICO_FRAGMENTS_H
+#include "pico_ipv4.h"
+#include "pico_ipv6.h"
+#include "pico_addressing.h"
+#include "pico_frame.h"
+
+void pico_ipv6_process_frag(struct pico_ipv6_exthdr *frag, struct pico_frame *f, uint8_t proto);
+void pico_ipv4_process_frag(struct pico_ipv4_hdr *hdr, struct pico_frame *f, uint8_t proto);
+
+#endif
diff -ruN picotcp/build/include/pico_frame.h stack/picotcp/build/include/pico_frame.h
--- picotcp/build/include/pico_frame.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_frame.h	2023-12-29 11:06:34.274201400 +0100
@@ -0,0 +1,131 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_FRAME
+#define INCLUDE_PICO_FRAME
+#include "pico_config.h"
+
+
+#define PICO_FRAME_FLAG_BCAST               (0x01)
+#define PICO_FRAME_FLAG_EXT_BUFFER          (0x02)
+#define PICO_FRAME_FLAG_EXT_USAGE_COUNTER   (0x04)
+#define PICO_FRAME_FLAG_SACKED              (0x80)
+#define PICO_FRAME_FLAG_LL_SEC              (0x40)
+#define PICO_FRAME_FLAG_SLP_FRAG            (0x20)
+#define IS_BCAST(f) ((f->flags & PICO_FRAME_FLAG_BCAST) == PICO_FRAME_FLAG_BCAST)
+
+
+struct pico_socket;
+
+
+struct pico_frame {
+
+    /* Connector for queues */
+    struct pico_frame *next;
+
+    /* Start of the whole buffer, total frame length. */
+    unsigned char *buffer;
+    uint32_t buffer_len;
+
+    /* For outgoing packets: this is the meaningful buffer. */
+    unsigned char *start;
+    uint32_t len;
+
+    /* Pointer to usage counter */
+    uint32_t *usage_count;
+
+    /* Pointer to protocol headers */
+    uint8_t *datalink_hdr;
+
+    uint8_t *net_hdr;
+    uint16_t net_len;
+    uint8_t *transport_hdr;
+    uint16_t transport_len;
+    uint8_t *app_hdr;
+    uint16_t app_len;
+
+    /* Pointer to the phisical device this packet belongs to.
+     * Should be valid in both routing directions
+     */
+    struct pico_device *dev;
+
+    pico_time timestamp;
+
+    /* Failures due to bad datalink addressing. */
+    uint16_t failure_count;
+
+    /* Protocol over IP */
+    uint8_t proto;
+
+    /* PICO_FRAME_FLAG_* */
+    uint8_t flags;
+
+    /* Pointer to payload */
+    unsigned char *payload;
+    uint16_t payload_len;
+
+#if defined(PICO_SUPPORT_IPV4FRAG) || defined(PICO_SUPPORT_IPV6FRAG)
+    /* Payload fragmentation info */
+    uint16_t frag;
+#endif
+
+#if defined(PICO_SUPPORT_6LOWPAN)
+    uint32_t hash;
+    union pico_ll_addr src;
+    union pico_ll_addr dst;
+#endif
+
+    /* Pointer to socket */
+    struct pico_socket *sock;
+
+    /* Pointer to transport info, used to store remote UDP endpoint (IP + port) */
+    void *info;
+
+    /*Priority. "best-effort" priority, the default value is 0. Priority can be in between -10 and +10*/
+    int8_t priority;
+    uint8_t transport_flags_saved;
+
+    /* Callback to notify listener when the buffer has been discarded */
+    void (*notify_free)(uint8_t *);
+
+    uint8_t send_ttl; /* Special TTL/HOPS value, 0 = auto assign */
+    uint8_t send_tos; /* Type of service */
+};
+
+/** frame alloc/dealloc/copy **/
+void pico_frame_discard(struct pico_frame *f);
+struct pico_frame *pico_frame_copy(struct pico_frame *f);
+struct pico_frame *pico_frame_deepcopy(struct pico_frame *f);
+struct pico_frame *pico_frame_alloc(uint32_t size);
+int pico_frame_grow(struct pico_frame *f, uint32_t size);
+int pico_frame_grow_head(struct pico_frame *f, uint32_t size);
+struct pico_frame *pico_frame_alloc_skeleton(uint32_t size, int ext_buffer);
+int pico_frame_skeleton_set_buffer(struct pico_frame *f, void *buf);
+uint16_t pico_checksum(void *inbuf, uint32_t len);
+uint16_t pico_dualbuffer_checksum(void *b1, uint32_t len1, void *b2, uint32_t len2);
+
+static inline int pico_is_digit(char c)
+{
+    if (c < '0' || c > '9')
+        return 0;
+
+    return 1;
+}
+
+static inline int pico_is_hex(char c)
+{
+    if (c >= '0' && c <= '9')
+        return 1;
+
+    if (c >= 'a' && c <= 'f')
+        return 1;
+
+    if (c >= 'A' && c <= 'F')
+        return 1;
+
+    return 0;
+}
+
+#endif
diff -ruN picotcp/build/include/pico_hotplug_detection.h stack/picotcp/build/include/pico_hotplug_detection.h
--- picotcp/build/include/pico_hotplug_detection.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_hotplug_detection.h	2023-12-29 11:06:34.352900600 +0100
@@ -0,0 +1,23 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Frederik Van Slycken
+ *********************************************************************/
+#ifndef INCLUDE_PICO_SUPPORT_HOTPLUG
+#define INCLUDE_PICO_SUPPORT_HOTPLUG
+#include "pico_stack.h"
+
+#define PICO_HOTPLUG_EVENT_UP  1  /* link went up */
+#define PICO_HOTPLUG_EVENT_DOWN  2  /* link went down */
+
+#define PICO_HOTPLUG_INTERVAL 100
+
+/* register your callback to be notified of hotplug events on a certain device.
+ * Note that each callback will be called at least once, shortly after adding, for initialization.
+ */
+int pico_hotplug_register(struct pico_device *dev, void (*cb)(struct pico_device *dev, int event));
+int pico_hotplug_deregister(struct pico_device *dev, void (*cb)(struct pico_device *dev, int event));
+
+#endif /* _INCLUDE_PICO_SUPPORT_HOTPLUG */
+
diff -ruN picotcp/build/include/pico_icmp4.h stack/picotcp/build/include/pico_icmp4.h
--- picotcp/build/include/pico_icmp4.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_icmp4.h	2023-12-29 11:06:34.354224200 +0100
@@ -0,0 +1,162 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_ICMP4
+#define INCLUDE_PICO_ICMP4
+#include "pico_defines.h"
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+
+
+extern struct pico_protocol pico_proto_icmp4;
+
+PACKED_STRUCT_DEF pico_icmp4_hdr {
+    uint8_t type;
+    uint8_t code;
+    uint16_t crc;
+
+    /* hun */
+    PACKED_UNION_DEF hun_u {
+        uint8_t ih_pptr;
+        struct pico_ip4 ih_gwaddr;
+        PEDANTIC_STRUCT_DEF ih_idseq_s {
+            uint16_t idseq_id;
+            uint16_t idseq_seq;
+        } ih_idseq;
+        uint32_t ih_void;
+        PEDANTIC_STRUCT_DEF ih_pmtu_s {
+            uint16_t ipm_void;
+            uint16_t ipm_nmtu;
+        } ih_pmtu;
+        PEDANTIC_STRUCT_DEF ih_rta_s {
+            uint8_t rta_numgw;
+            uint8_t rta_wpa;
+            uint16_t rta_lifetime;
+        } ih_rta;
+    } hun;
+
+    /* dun */
+    PACKED_UNION_DEF dun_u {
+        PEDANTIC_STRUCT_DEF id_ts_s {
+            uint32_t ts_otime;
+            uint32_t ts_rtime;
+            uint32_t ts_ttime;
+        } id_ts;
+        PEDANTIC_STRUCT_DEF id_ip_s {
+            uint32_t ip_options;
+            uint32_t ip_data_hi;
+            uint32_t ip_data_lo;
+        } id_ip;
+        PEDANTIC_STRUCT_DEF id_ra_s {
+            uint32_t ira_addr;
+            uint32_t ira_pref;
+        } id_ra;
+        uint32_t id_mask;
+        uint8_t id_data[1];
+    } dun;
+};
+
+#define PICO_ICMPHDR_DRY_SIZE  4
+#define PICO_ICMPHDR_UN_SIZE  8u
+
+#define PICO_ICMP_ECHOREPLY    0
+#define PICO_ICMP_DEST_UNREACH 3
+#define PICO_ICMP_SOURCE_QUENCH  4
+#define PICO_ICMP_REDIRECT   5
+#define PICO_ICMP_ECHO   8
+#define PICO_ICMP_TIME_EXCEEDED  11
+#define PICO_ICMP_PARAMETERPROB  12
+#define PICO_ICMP_TIMESTAMP    13
+#define PICO_ICMP_TIMESTAMPREPLY 14
+#define PICO_ICMP_INFO_REQUEST 15
+#define PICO_ICMP_INFO_REPLY   16
+#define PICO_ICMP_ADDRESS    17
+#define PICO_ICMP_ADDRESSREPLY 18
+
+
+#define  PICO_ICMP_UNREACH    3
+#define  PICO_ICMP_SOURCEQUENCH  4
+#define  PICO_ICMP_ROUTERADVERT  9
+#define  PICO_ICMP_ROUTERSOLICIT  10
+#define  PICO_ICMP_TIMXCEED    11
+#define  PICO_ICMP_PARAMPROB    12
+#define  PICO_ICMP_TSTAMP    13
+#define  PICO_ICMP_TSTAMPREPLY  14
+#define  PICO_ICMP_IREQ    15
+#define  PICO_ICMP_IREQREPLY    16
+#define  PICO_ICMP_MASKREQ    17
+#define  PICO_ICMP_MASKREPLY    18
+
+#define  PICO_ICMP_MAXTYPE    18
+
+
+#define  PICO_ICMP_UNREACH_NET          0
+#define  PICO_ICMP_UNREACH_HOST          1
+#define  PICO_ICMP_UNREACH_PROTOCOL          2
+#define  PICO_ICMP_UNREACH_PORT          3
+#define  PICO_ICMP_UNREACH_NEEDFRAG          4
+#define  PICO_ICMP_UNREACH_SRCFAIL          5
+#define  PICO_ICMP_UNREACH_NET_UNKNOWN        6
+#define  PICO_ICMP_UNREACH_HOST_UNKNOWN       7
+#define  PICO_ICMP_UNREACH_ISOLATED          8
+#define  PICO_ICMP_UNREACH_NET_PROHIB          9
+#define  PICO_ICMP_UNREACH_HOST_PROHIB        10
+#define  PICO_ICMP_UNREACH_TOSNET          11
+#define  PICO_ICMP_UNREACH_TOSHOST          12
+#define  PICO_ICMP_UNREACH_FILTER_PROHIB      13
+#define  PICO_ICMP_UNREACH_HOST_PRECEDENCE    14
+#define  PICO_ICMP_UNREACH_PRECEDENCE_CUTOFF  15
+
+
+#define  PICO_ICMP_REDIRECT_NET  0
+#define  PICO_ICMP_REDIRECT_HOST  1
+#define  PICO_ICMP_REDIRECT_TOSNET  2
+#define  PICO_ICMP_REDIRECT_TOSHOST  3
+
+
+#define  PICO_ICMP_TIMXCEED_INTRANS  0
+#define  PICO_ICMP_TIMXCEED_REASS  1
+
+
+#define  PICO_ICMP_PARAMPROB_OPTABSENT 1
+
+#define PICO_SIZE_ICMP4HDR ((sizeof(struct pico_icmp4_hdr)))
+
+struct pico_icmp4_stats
+{
+    struct pico_ip4 dst;
+    unsigned long size;
+    unsigned long seq;
+    pico_time time;
+    unsigned long ttl;
+    int err;
+};
+
+int pico_icmp4_port_unreachable(struct pico_frame *f);
+int pico_icmp4_proto_unreachable(struct pico_frame *f);
+int pico_icmp4_dest_unreachable(struct pico_frame *f);
+int pico_icmp4_mtu_exceeded(struct pico_frame *f);
+int pico_icmp4_ttl_expired(struct pico_frame *f);
+int pico_icmp4_frag_expired(struct pico_frame *f);
+int pico_icmp4_ping(char *dst, int count, int interval, int timeout, int size, void (*cb)(struct pico_icmp4_stats *));
+int pico_icmp4_ping_abort(int id);
+
+#ifdef PICO_SUPPORT_ICMP4
+int pico_icmp4_packet_filtered(struct pico_frame *f);
+int pico_icmp4_param_problem(struct pico_frame *f, uint8_t code);
+#else
+# define pico_icmp4_packet_filtered(f) (-1)
+# define pico_icmp4_param_problem(f, c) (-1)
+#endif /* PICO_SUPPORT_ICMP4 */
+
+#define PICO_PING_ERR_REPLIED 0
+#define PICO_PING_ERR_TIMEOUT 1
+#define PICO_PING_ERR_UNREACH 2
+#define PICO_PING_ERR_ABORTED 3
+#define PICO_PING_ERR_PENDING 0xFFFF
+
+#endif
diff -ruN picotcp/build/include/pico_icmp6.h stack/picotcp/build/include/pico_icmp6.h
--- picotcp/build/include/pico_icmp6.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_icmp6.h	2023-12-29 11:06:34.355546800 +0100
@@ -0,0 +1,326 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_ICMP6
+#define _INCLUDE_PICO_ICMP6
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_mld.h"
+/* ICMP header sizes */
+#define PICO_ICMP6HDR_DRY_SIZE          4
+#define PICO_ICMP6HDR_ECHO_REQUEST_SIZE 8
+#define PICO_ICMP6HDR_DEST_UNREACH_SIZE 8
+#define PICO_ICMP6HDR_TIME_XCEEDED_SIZE 8
+#define PICO_ICMP6HDR_PARAM_PROBLEM_SIZE 8
+#define PICO_ICMP6HDR_NEIGH_SOL_SIZE    24
+#define PICO_ICMP6HDR_NEIGH_ADV_SIZE    24
+#define PICO_ICMP6HDR_ROUTER_SOL_SIZE   8
+#define PICO_ICMP6HDR_ROUTER_SOL_SIZE_6LP 16
+#define PICO_ICMP6HDR_ROUTER_ADV_SIZE   16
+#define PICO_ICMP6HDR_REDIRECT_SIZE     40
+
+/* ICMP types */
+#define PICO_ICMP6_DEST_UNREACH        1
+#define PICO_ICMP6_PKT_TOO_BIG         2
+#define PICO_ICMP6_TIME_EXCEEDED       3
+#define PICO_ICMP6_PARAM_PROBLEM       4
+#define PICO_ICMP6_ECHO_REQUEST        128
+#define PICO_ICMP6_ECHO_REPLY          129
+#define PICO_ICMP6_ROUTER_SOL          133
+#define PICO_ICMP6_ROUTER_ADV          134
+#define PICO_ICMP6_NEIGH_SOL           135
+#define PICO_ICMP6_NEIGH_ADV           136
+#define PICO_ICMP6_REDIRECT            137
+
+/* destination unreachable codes */
+#define PICO_ICMP6_UNREACH_NOROUTE     0
+#define PICO_ICMP6_UNREACH_ADMIN       1
+#define PICO_ICMP6_UNREACH_SRCSCOPE    2
+#define PICO_ICMP6_UNREACH_ADDR        3
+#define PICO_ICMP6_UNREACH_PORT        4
+#define PICO_ICMP6_UNREACH_SRCFILTER   5
+#define PICO_ICMP6_UNREACH_REJROUTE    6
+
+/* time exceeded codes */
+#define PICO_ICMP6_TIMXCEED_INTRANS    0
+#define PICO_ICMP6_TIMXCEED_REASS      1
+
+/* parameter problem codes */
+#define PICO_ICMP6_PARAMPROB_HDRFIELD  0
+#define PICO_ICMP6_PARAMPROB_NXTHDR    1
+#define PICO_ICMP6_PARAMPROB_IPV6OPT   2
+
+/* ping error codes */
+#define PICO_PING6_ERR_REPLIED         0
+#define PICO_PING6_ERR_TIMEOUT         1
+#define PICO_PING6_ERR_UNREACH         2
+#define PICO_PING6_ERR_ABORTED         3
+#define PICO_PING6_ERR_PENDING         0xFFFF
+
+/* ND configuration */
+#define PICO_ND_MAX_FRAMES_QUEUED      4 /* max frames queued while awaiting address resolution */
+
+/* ND RFC constants */
+#define PICO_ND_MAX_SOLICIT            3
+#define PICO_ND_MAX_NEIGHBOR_ADVERT    3
+#define PICO_ND_DELAY_INCOMPLETE       1000 /* msec */
+#define PICO_ND_DELAY_FIRST_PROBE_TIME 5000 /* msec */
+
+/* neighbor discovery options */
+#define PICO_ND_OPT_LLADDR_SRC         1
+#define PICO_ND_OPT_LLADDR_TGT         2
+#define PICO_ND_OPT_PREFIX             3
+#define PICO_ND_OPT_REDIRECT           4
+#define PICO_ND_OPT_MTU                5
+#define PICO_ND_OPT_RDNSS             25 /* RFC 5006 */
+#define PICO_ND_OPT_ARO               33 /* RFC 6775 */
+#define PICO_ND_OPT_6CO               34 /* RFC 6775 */
+#define PICO_ND_OPT_ABRO              35 /* RFC 6775 */
+
+/* ND advertisement flags */
+#define PICO_ND_ROUTER             0x80000000
+#define PICO_ND_SOLICITED          0x40000000
+#define PICO_ND_OVERRIDE           0x20000000
+#define IS_ROUTER(x) (long_be(x->msg.info.neigh_adv.rsor) & (PICO_ND_ROUTER))           /* router flag set? */
+#define IS_SOLICITED(x) (long_be(x->msg.info.neigh_adv.rsor) & (PICO_ND_SOLICITED))     /* solicited flag set? */
+#define IS_OVERRIDE(x) (long_be(x->msg.info.neigh_adv.rsor) & (PICO_ND_OVERRIDE))   /* override flag set? */
+
+#define PICO_ND_PREFIX_LIFETIME_INF    0xFFFFFFFFu
+/* #define PICO_ND_DESTINATION_LRU_TIME   600000u / * msecs (10min) * / */
+
+/* custom defines */
+#define PICO_ICMP6_ND_UNICAST          0
+#define PICO_ICMP6_ND_ANYCAST          1
+#define PICO_ICMP6_ND_SOLICITED        2
+#define PICO_ICMP6_ND_DAD              3
+#define PICO_ICMP6_ND_DEREGISTER       4
+
+#define PICO_ICMP6_MAX_RTR_SOL_DELAY   1000
+
+#define PICO_ICMP6_OPT_LLADDR_SIZE (8)
+
+/******************************************************************************
+ *  6LoWPAN Constants
+ ******************************************************************************/
+
+/* Address registration lifetime */
+#define PICO_6LP_ND_DEFAULT_LIFETIME    (120) /* TWO HOURS */
+
+extern struct pico_protocol pico_proto_icmp6;
+
+PACKED_STRUCT_DEF pico_icmp6_hdr {
+    uint8_t type;
+    uint8_t code;
+    uint16_t crc;
+
+    PACKED_UNION_DEF icmp6_msg_u {
+        /* error messages */
+        PACKED_UNION_DEF icmp6_err_u {
+            PEDANTIC_STRUCT_DEF dest_unreach_s {
+                uint32_t unused;
+            } dest_unreach;
+            PEDANTIC_STRUCT_DEF pkt_too_big_s {
+                uint32_t mtu;
+            } pkt_too_big;
+            PEDANTIC_STRUCT_DEF time_exceeded_s {
+                uint32_t unused;
+            } time_exceeded;
+            PEDANTIC_STRUCT_DEF param_problem_s {
+                uint32_t ptr;
+            } param_problem;
+        } err;
+
+        /* informational messages */
+        PACKED_UNION_DEF icmp6_info_u {
+            PEDANTIC_STRUCT_DEF echo_request_s {
+                uint16_t id;
+                uint16_t seq;
+            } echo_request;
+            PEDANTIC_STRUCT_DEF echo_reply_s {
+                uint16_t id;
+                uint16_t seq;
+            } echo_reply;
+            PEDANTIC_STRUCT_DEF router_sol_s {
+                uint32_t unused;
+            } router_sol;
+            PEDANTIC_STRUCT_DEF router_adv_s {
+                uint8_t hop;
+                uint8_t mor;
+                uint16_t life_time;
+                uint32_t reachable_time;
+                uint32_t retrans_time;
+            } router_adv;
+            PEDANTIC_STRUCT_DEF neigh_sol_s {
+                uint32_t unused;
+                struct pico_ip6 target;
+            } neigh_sol;
+            PEDANTIC_STRUCT_DEF neigh_adv_s {
+                uint32_t rsor;
+                struct pico_ip6 target;
+            } neigh_adv;
+            PEDANTIC_STRUCT_DEF redirect_s {
+                uint32_t reserved;
+                struct pico_ip6 target;
+                struct pico_ip6 dest;
+            } redirect;
+            PEDANTIC_STRUCT_DEF mld_s {
+                uint16_t max_resp_time;
+                uint16_t reserved;
+                struct pico_ip6 mmcast_group;
+                /*MLDv2*/
+                uint8_t reserverd; /* With S and QRV */
+                uint8_t QQIC;
+                uint16_t nbr_src;
+                struct pico_ip6 src[1];
+            } mld;
+            /* 6LoWPAN Duplicate Address Message */
+            PEDANTIC_STRUCT_DEF da_s {
+                uint8_t status;
+                uint8_t reserved;
+                uint16_t lifetime;
+                struct pico_6lowpan_ext eui64;
+                struct pico_ip6 addr;
+            } da;
+        } info;
+    } msg;
+};
+
+PACKED_UNION_DEF pico_hw_addr {
+    struct pico_eth mac;
+#ifdef PICO_SUPPORT_6LOWPAN
+    union pico_6lowpan_u pan;
+#endif /* PICO_SUPPORT_6LOWPAN */
+    uint8_t data[8];
+};
+
+/******************************************************************************
+ *  ICMP6 Neighbor Discovery Options
+ ******************************************************************************/
+
+PACKED_STRUCT_DEF pico_icmp6_opt_lladdr
+{
+    uint8_t type;
+    uint8_t len;
+    union pico_hw_addr addr;
+};
+
+PACKED_STRUCT_DEF pico_icmp6_opt_prefix
+{
+    uint8_t type;
+    uint8_t len;
+    uint8_t prefix_len;
+    uint8_t res : 6;
+    uint8_t aac : 1;
+    uint8_t onlink : 1;
+    uint32_t val_lifetime;
+    uint32_t pref_lifetime;
+    uint32_t reserved;
+    struct pico_ip6 prefix;
+};
+
+PACKED_STRUCT_DEF pico_icmp6_opt_mtu
+{
+    uint8_t type;
+    uint8_t len;
+    uint16_t res;
+    uint32_t mtu;
+};
+
+PACKED_STRUCT_DEF pico_icmp6_opt_redirect
+{
+    uint8_t type;
+    uint8_t len;
+    uint16_t res0;
+    uint32_t res1;
+};
+
+PACKED_STRUCT_DEF pico_icmp6_opt_rdnss
+{
+    uint8_t type;
+    uint8_t len;
+    uint16_t res0;
+    uint32_t lifetime;
+    struct pico_ip6 *addr;
+};
+
+PACKED_STRUCT_DEF pico_icmp6_opt_na
+{
+    uint8_t type;
+    uint8_t len;
+};
+
+/* 6LoWPAN Address Registration Option (ARO) */
+PACKED_STRUCT_DEF pico_icmp6_opt_aro
+{
+    uint8_t type;
+    uint8_t len;
+    uint8_t status;
+    uint8_t res0;
+    uint16_t res1;
+    uint16_t lifetime;
+    struct pico_6lowpan_ext eui64;
+};
+
+#define ICMP6_ARO_SUCCES    (0u)
+#define ICMP6_ARO_DUP       (1u)
+#define ICMP6_ARO_FULL      (2u)
+
+/* 6LoWPAN Context Option (6CO) */
+PACKED_STRUCT_DEF pico_icmp6_opt_6co
+{
+    uint8_t type;
+    uint8_t len;
+    uint8_t clen;
+    uint8_t id: 4;
+    uint8_t res: 3;
+    uint8_t c: 1;
+    uint16_t lifetime;
+    uint8_t prefix;
+};
+
+/* 6LoWPAN Authoritative Border Router Option (ABRO) */
+PACKED_STRUCT_DEF pico_icmp6_opt_abro
+{
+    uint8_t type;
+    uint8_t len;
+    uint16_t version_low;
+    uint16_t version_high;
+    uint16_t lifetime;
+    struct pico_ip6 addr;
+};
+
+struct pico_icmp6_stats
+{
+    unsigned long size;
+    unsigned long seq;
+    pico_time time;
+    unsigned long ttl;
+    int err;
+    struct pico_ip6 dst;
+};
+
+int pico_icmp6_ping(char *dst, int count, int interval, int timeout, int size, void (*cb)(struct pico_icmp6_stats *), struct pico_device *dev);
+int pico_icmp6_ping_abort(int id);
+
+
+int pico_icmp6_neighbor_solicitation(struct pico_device *dev, struct pico_ip6 *tgt, uint8_t type, struct pico_ip6 *dst);
+int pico_icmp6_neighbor_advertisement(struct pico_frame *f, struct pico_ip6 *target);
+int pico_icmp6_router_solicitation(struct pico_device *dev, struct pico_ip6 *src, struct pico_ip6 *dst);
+
+int pico_icmp6_port_unreachable(struct pico_frame *f);
+int pico_icmp6_proto_unreachable(struct pico_frame *f);
+int pico_icmp6_dest_unreachable(struct pico_frame *f);
+int pico_icmp6_ttl_expired(struct pico_frame *f);
+int pico_icmp6_packet_filtered(struct pico_frame *f);
+int pico_icmp6_parameter_problem(struct pico_frame *f, uint8_t problem, uint32_t ptr);
+int pico_icmp6_pkt_too_big(struct pico_frame *f);
+int pico_icmp6_frag_expired(struct pico_frame *f);
+
+uint16_t pico_icmp6_checksum(struct pico_frame *f);
+int pico_icmp6_router_advertisement(struct pico_device *dev, struct pico_ip6 *dst);
+
+#endif
diff -ruN picotcp/build/include/pico_igmp.h stack/picotcp/build/include/pico_igmp.h
--- picotcp/build/include/pico_igmp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_igmp.h	2023-12-29 11:06:34.357529700 +0100
@@ -0,0 +1,26 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Authors: Kristof Roelants, Simon Maes, Brecht Van Cauwenberghe
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_IGMP
+#define INCLUDE_PICO_IGMP
+
+#define PICO_IGMPV1               1
+#define PICO_IGMPV2               2
+#define PICO_IGMPV3               3
+
+#define PICO_IGMP_STATE_CREATE    1
+#define PICO_IGMP_STATE_UPDATE    2
+#define PICO_IGMP_STATE_DELETE    3
+
+#define PICO_IGMP_QUERY_INTERVAL  125
+
+extern struct pico_protocol pico_proto_igmp;
+
+int pico_igmp_state_change(struct pico_ip4 *mcast_link, struct pico_ip4 *mcast_group, uint8_t filter_mode, struct pico_tree *_MCASTFilter, uint8_t state);
+#endif /* _INCLUDE_PICO_IGMP */
diff -ruN picotcp/build/include/pico_ipfilter.h stack/picotcp/build/include/pico_ipfilter.h
--- picotcp/build/include/pico_ipfilter.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_ipfilter.h	2023-12-29 11:06:34.358852000 +0100
@@ -0,0 +1,29 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Simon Maes
+ *********************************************************************/
+#ifndef INCLUDE_PICO_IPFILTER
+#define INCLUDE_PICO_IPFILTER
+
+#include "pico_device.h"
+
+enum filter_action {
+    FILTER_PRIORITY = 0,
+    FILTER_REJECT,
+    FILTER_DROP,
+    FILTER_COUNT
+};
+
+uint32_t pico_ipv4_filter_add(struct pico_device *dev, uint8_t proto,
+                              struct pico_ip4 *out_addr, struct pico_ip4 *out_addr_netmask, struct pico_ip4 *in_addr,
+                              struct pico_ip4 *in_addr_netmask, uint16_t out_port, uint16_t in_port,
+                              int8_t priority, uint8_t tos, enum filter_action action);
+
+int pico_ipv4_filter_del(uint32_t filter_id);
+
+int ipfilter(struct pico_frame *f);
+
+#endif /* _INCLUDE_PICO_IPFILTER */
+
diff -ruN picotcp/build/include/pico_ipv4.h stack/picotcp/build/include/pico_ipv4.h
--- picotcp/build/include/pico_ipv4.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_ipv4.h	2023-12-29 11:06:34.360836100 +0100
@@ -0,0 +1,115 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_IPV4
+#define INCLUDE_PICO_IPV4
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_tree.h"
+
+#define PICO_IPV4_INADDR_ANY 0x00000000U
+
+#define PICO_IPV4_MTU (1500u)
+#define PICO_SIZE_IP4HDR (uint32_t)((sizeof(struct pico_ipv4_hdr)))
+#define PICO_IPV4_MAXPAYLOAD (PICO_IPV4_MTU - PICO_SIZE_IP4HDR)
+#define PICO_IPV4_DONTFRAG 0x4000U
+#define PICO_IPV4_MOREFRAG 0x2000U
+#define PICO_IPV4_EVIL      0x8000U
+#define PICO_IPV4_FRAG_MASK 0x1FFFU
+#define PICO_IPV4_DEFAULT_TTL 64
+#ifndef MBED
+    #define PICO_IPV4_FRAG_MAX_SIZE (uint32_t)(63 * 1024)
+#else
+    #define PICO_IPV4_FRAG_MAX_SIZE PICO_DEFAULT_SOCKETQ
+#endif
+
+extern struct pico_protocol pico_proto_ipv4;
+
+PACKED_STRUCT_DEF pico_ipv4_hdr {
+    uint8_t vhl;
+    uint8_t tos;
+    uint16_t len;
+    uint16_t id;
+    uint16_t frag;
+    uint8_t ttl;
+    uint8_t proto;
+    uint16_t crc;
+    struct pico_ip4 src;
+    struct pico_ip4 dst;
+    uint8_t options[];
+};
+
+PACKED_STRUCT_DEF pico_ipv4_pseudo_hdr
+{
+    struct pico_ip4 src;
+    struct pico_ip4 dst;
+    uint8_t zeros;
+    uint8_t proto;
+    uint16_t len;
+};
+
+/* Interface: link to device */
+struct pico_mcast_list;
+
+struct pico_ipv4_link
+{
+    struct pico_device *dev;
+    struct pico_ip4 address;
+    struct pico_ip4 netmask;
+#ifdef PICO_SUPPORT_MCAST
+    struct pico_tree *MCASTGroups;
+    uint8_t mcast_compatibility;
+    uint8_t mcast_last_query_interval;
+#endif
+};
+
+
+struct pico_ipv4_route
+{
+    struct pico_ip4 dest;
+    struct pico_ip4 netmask;
+    struct pico_ip4 gateway;
+    struct pico_ipv4_link *link;
+    uint32_t metric;
+};
+
+extern struct pico_tree Routes;
+
+
+int pico_ipv4_compare(struct pico_ip4 *a, struct pico_ip4 *b);
+int pico_ipv4_to_string(char *ipbuf, const uint32_t ip);
+int pico_string_to_ipv4(const char *ipstr, uint32_t *ip);
+int pico_ipv4_valid_netmask(uint32_t mask);
+int pico_ipv4_is_unicast(uint32_t address);
+int pico_ipv4_is_multicast(uint32_t address);
+int pico_ipv4_is_broadcast(uint32_t addr);
+int pico_ipv4_is_loopback(uint32_t addr);
+int pico_ipv4_is_valid_src(uint32_t addr, struct pico_device *dev);
+
+int pico_ipv4_link_add(struct pico_device *dev, struct pico_ip4 address, struct pico_ip4 netmask);
+int pico_ipv4_link_del(struct pico_device *dev, struct pico_ip4 address);
+int pico_ipv4_rebound(struct pico_frame *f);
+
+int pico_ipv4_frame_push(struct pico_frame *f, struct pico_ip4 *dst, uint8_t proto);
+struct pico_ipv4_link *pico_ipv4_link_get(struct pico_ip4 *address);
+struct pico_ipv4_link *pico_ipv4_link_by_dev(struct pico_device *dev);
+struct pico_ipv4_link *pico_ipv4_link_by_dev_next(struct pico_device *dev, struct pico_ipv4_link *last);
+struct pico_device *pico_ipv4_link_find(struct pico_ip4 *address);
+struct pico_ip4 *pico_ipv4_source_find(const struct pico_ip4 *dst);
+struct pico_device *pico_ipv4_source_dev_find(const struct pico_ip4 *dst);
+int pico_ipv4_route_add(struct pico_ip4 address, struct pico_ip4 netmask, struct pico_ip4 gateway, int metric, struct pico_ipv4_link *link);
+int pico_ipv4_route_del(struct pico_ip4 address, struct pico_ip4 netmask, int metric);
+struct pico_ip4 pico_ipv4_route_get_gateway(struct pico_ip4 *addr);
+void pico_ipv4_route_set_bcast_link(struct pico_ipv4_link *link);
+void pico_ipv4_unreachable(struct pico_frame *f, int err);
+
+int pico_ipv4_mcast_join(struct pico_ip4 *mcast_link, struct pico_ip4 *mcast_group, uint8_t reference_count, uint8_t filter_mode, struct pico_tree *MCASTFilter);
+int pico_ipv4_mcast_leave(struct pico_ip4 *mcast_link, struct pico_ip4 *mcast_group, uint8_t reference_count, uint8_t filter_mode, struct pico_tree *MCASTFilter);
+struct pico_ipv4_link *pico_ipv4_get_default_mcastlink(void);
+int pico_ipv4_cleanup_links(struct pico_device *dev);
+
+#endif /* _INCLUDE_PICO_IPV4 */
diff -ruN picotcp/build/include/pico_ipv6.h stack/picotcp/build/include/pico_ipv6.h
--- picotcp/build/include/pico_ipv6.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_ipv6.h	2023-12-29 11:06:34.362158700 +0100
@@ -0,0 +1,182 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_IPV6
+#define _INCLUDE_PICO_IPV6
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_ipv4.h"
+
+#define PICO_SIZE_IP6HDR ((uint32_t)(sizeof(struct pico_ipv6_hdr)))
+#define PICO_IPV6_DEFAULT_HOP 64
+#define PICO_IPV6_MIN_MTU 1280
+#define PICO_IPV6_STRING 46
+
+#define PICO_IPV6_EXTHDR_HOPBYHOP 0
+#define PICO_IPV6_EXTHDR_ROUTING 43
+#define PICO_IPV6_EXTHDR_FRAG 44
+#define PICO_IPV6_EXTHDR_ESP 50
+#define PICO_IPV6_EXTHDR_AUTH 51
+#define PICO_IPV6_EXTHDR_NONE 59
+#define PICO_IPV6_EXTHDR_DESTOPT 60
+
+#define PICO_IPV6_EXTHDR_OPT_ROUTER_ALERT 5
+#define PICO_IPV6_EXTHDR_OPT_ROUTER_ALERT_DATALEN 2
+
+#define HBH_LEN(hbh) ((((hbh->ext.hopbyhop.len + 1) << 3) - 2)) /* len in bytes, minus nxthdr and len byte */
+#define IPV6_OPTLEN(x) ((uint16_t)(((x + 1) << 3)))
+
+extern const uint8_t PICO_IP6_ANY[PICO_SIZE_IP6];
+extern struct pico_protocol pico_proto_ipv6;
+extern struct pico_tree IPV6Routes;
+
+PACKED_STRUCT_DEF pico_ipv6_hdr {
+    uint32_t vtf;
+    uint16_t len;
+    uint8_t nxthdr;
+    uint8_t hop;
+    struct pico_ip6 src;
+    struct pico_ip6 dst;
+};
+
+PACKED_STRUCT_DEF pico_ipv6_pseudo_hdr
+{
+    struct pico_ip6 src;
+    struct pico_ip6 dst;
+    uint32_t len;
+    uint8_t zero[3];
+    uint8_t nxthdr;
+};
+
+struct pico_ipv6_link
+{
+    struct pico_device *dev;
+    struct pico_ip6 address;
+    struct pico_ip6 netmask;
+    uint8_t istentative : 1;
+    uint8_t isduplicate : 1;
+    uint32_t dad_timer;
+    uint16_t dup_detect_retrans;
+    uint8_t retrans;
+    pico_time expire_time;
+#ifdef PICO_SUPPORT_MCAST
+    struct pico_tree *MCASTGroups;
+    uint8_t mcast_compatibility;
+    uint8_t mcast_last_query_interval;
+#endif
+};
+
+union pico_link {
+    struct pico_ipv4_link ipv4;
+    struct pico_ipv6_link ipv6;
+};
+
+struct pico_ipv6_hbhoption {
+    uint8_t type;
+    uint8_t len;
+};
+#ifdef PICO_SUPPORT_MCAST
+struct pico_ipv6_mcast_group {
+    uint8_t filter_mode;
+    uint16_t reference_count;
+    struct pico_ip6 mcast_addr;
+    struct pico_tree MCASTSources;
+};
+#endif
+struct pico_ipv6_destoption {
+    uint8_t type;
+    uint8_t len;
+};
+
+struct pico_ipv6_route
+{
+    struct pico_ip6 dest;
+    struct pico_ip6 netmask;
+    struct pico_ip6 gateway;
+    pico_time backoff;
+    uint8_t retrans;
+    struct pico_ipv6_link *link;
+    uint32_t metric;
+};
+
+PACKED_STRUCT_DEF pico_ipv6_exthdr {
+    uint8_t nxthdr;
+
+    PACKED_UNION_DEF ipv6_ext_u {
+        PEDANTIC_STRUCT_DEF hopbyhop_s {
+            uint8_t len;
+        } hopbyhop;
+
+        PEDANTIC_STRUCT_DEF destopt_s {
+            uint8_t len;
+        } destopt;
+
+        PEDANTIC_STRUCT_DEF routing_s {
+            uint8_t len;
+            uint8_t routtype;
+            uint8_t segleft;
+        } routing;
+
+        PEDANTIC_STRUCT_DEF fragmentation_s {
+            uint8_t res;
+            uint8_t om[2];
+            uint8_t id[4];
+        } frag;
+    } ext;
+};
+
+int pico_ipv6_compare(struct pico_ip6 *a, struct pico_ip6 *b);
+int pico_string_to_ipv6(const char *ipstr, uint8_t *ip);
+int pico_ipv6_to_string(char *ipbuf, const uint8_t ip[PICO_SIZE_IP6]);
+int pico_ipv6_is_unicast(struct pico_ip6 *a);
+int pico_ipv6_is_multicast(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_allhosts_multicast(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_solnode_multicast(const uint8_t addr[PICO_SIZE_IP6], struct pico_device *dev);
+int pico_ipv6_is_global(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_uniquelocal(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_sitelocal(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_linklocal(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_solicited(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_unspecified(const uint8_t addr[PICO_SIZE_IP6]);
+int pico_ipv6_is_localhost(const uint8_t addr[PICO_SIZE_IP6]);
+
+int pico_ipv6_frame_push(struct pico_frame *f, struct pico_ip6 *src, struct pico_ip6 *dst, uint8_t proto, int is_dad);
+int pico_ipv6_route_add(struct pico_ip6 address, struct pico_ip6 netmask, struct pico_ip6 gateway, int metric, struct pico_ipv6_link *link);
+int pico_ipv6_route_del(struct pico_ip6 address, struct pico_ip6 netmask, struct pico_ip6 gateway, int metric, struct pico_ipv6_link *link);
+void pico_ipv6_unreachable(struct pico_frame *f, uint8_t code);
+
+struct pico_ipv6_link *pico_ipv6_link_add(struct pico_device *dev, struct pico_ip6 address, struct pico_ip6 netmask);
+struct pico_ipv6_link *pico_ipv6_link_add_no_dad(struct pico_device *dev, struct pico_ip6 address, struct pico_ip6 netmask);
+int pico_ipv6_link_del(struct pico_device *dev, struct pico_ip6 address);
+int pico_ipv6_cleanup_links(struct pico_device *dev);
+struct pico_ipv6_link *pico_ipv6_link_istentative(struct pico_ip6 *address);
+struct pico_ipv6_link *pico_ipv6_link_get(struct pico_ip6 *address);
+struct pico_device *pico_ipv6_link_find(struct pico_ip6 *address);
+struct pico_ip6 pico_ipv6_route_get_gateway(struct pico_ip6 *addr);
+struct pico_ip6 *pico_ipv6_source_find(const struct pico_ip6 *dst);
+struct pico_device *pico_ipv6_source_dev_find(const struct pico_ip6 *dst);
+struct pico_ipv6_link *pico_ipv6_link_by_dev(struct pico_device *dev);
+struct pico_ipv6_link *pico_ipv6_link_by_dev_next(struct pico_device *dev, struct pico_ipv6_link *last);
+struct pico_ipv6_link *pico_ipv6_global_get(struct pico_device *dev);
+struct pico_ipv6_link *pico_ipv6_linklocal_get(struct pico_device *dev);
+struct pico_ipv6_link *pico_ipv6_sitelocal_get(struct pico_device *dev);
+struct pico_ipv6_link *pico_ipv6_prefix_configured(struct pico_ip6 *prefix);
+struct pico_ipv6_route *pico_ipv6_gateway_by_dev(struct pico_device *dev);
+struct pico_ipv6_route *pico_ipv6_gateway_by_dev_next(struct pico_device *dev, struct pico_ipv6_route *last);
+int pico_ipv6_lifetime_set(struct pico_ipv6_link *l, pico_time expire);
+void pico_ipv6_check_lifetime_expired(pico_time now, void *arg);
+int pico_ipv6_dev_routing_enable(struct pico_device *dev);
+int pico_ipv6_dev_routing_disable(struct pico_device *dev);
+void pico_ipv6_router_down(struct pico_ip6 *address);
+
+int pico_ipv6_mcast_join(struct pico_ip6 *mcast_link, struct pico_ip6 *mcast_group, uint8_t reference_count, uint8_t filter_mode, struct pico_tree *_MCASTFilter);
+int pico_ipv6_mcast_leave(struct pico_ip6 *mcast_link, struct pico_ip6 *mcast_group, uint8_t reference_count, uint8_t filter_mode, struct pico_tree *_MCASTFilter);
+
+struct pico_ipv6_link *pico_ipv6_get_default_mcastlink(void);
+
+int pico_ipv6_is_null_address(struct pico_ip6 *ip6);
+#endif
diff -ruN picotcp/build/include/pico_ipv6_nd.h stack/picotcp/build/include/pico_ipv6_nd.h
--- picotcp/build/include/pico_ipv6_nd.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_ipv6_nd.h	2023-12-29 11:06:34.363481700 +0100
@@ -0,0 +1,36 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef _INCLUDE_PICO_ND
+#define _INCLUDE_PICO_ND
+#include "pico_frame.h"
+#include "pico_ipv6.h"
+
+/* RFC constants */
+#define PICO_ND_REACHABLE_TIME         30000 /* msec */
+#define PICO_ND_RETRANS_TIMER          1000 /* msec */
+
+struct pico_nd_hostvars {
+    uint8_t routing;
+    uint8_t hoplimit;
+    pico_time basetime;
+    pico_time reachabletime;
+    pico_time retranstime;
+#ifdef PICO_SUPPORT_6LOWPAN
+    uint8_t lowpan_flags;
+#endif
+};
+
+void pico_ipv6_nd_init(void);
+struct pico_eth *pico_ipv6_get_neighbor(struct pico_frame *f);
+void pico_ipv6_nd_postpone(struct pico_frame *f);
+int pico_ipv6_nd_recv(struct pico_frame *f);
+
+#ifdef PICO_SUPPORT_6LOWPAN
+int pico_6lp_nd_start_soliciting(struct pico_ipv6_link *l, struct pico_ipv6_route *gw);
+void pico_6lp_nd_register(struct pico_ipv6_link *link);
+#endif
+
+#endif
diff -ruN picotcp/build/include/pico_mcast.h stack/picotcp/build/include/pico_mcast.h
--- picotcp/build/include/pico_mcast.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_mcast.h	2023-12-29 11:06:34.365465200 +0100
@@ -0,0 +1,53 @@
+#ifndef INCLUDE_PICO_MCAST
+#define INCLUDE_PICO_MCAST
+
+#define MCAST_MODE_IS_INCLUDE                 (1)
+#define MCAST_MODE_IS_EXCLUDE                 (2)
+#define MCAST_CHANGE_TO_INCLUDE_MODE          (3)
+#define MCAST_CHANGE_TO_EXCLUDE_MODE          (4)
+#define MCAST_ALLOW_NEW_SOURCES               (5)
+#define MCAST_BLOCK_OLD_SOURCES               (6)
+#define MCAST_EVENT_DELETE_GROUP              (0x0)
+#define MCAST_EVENT_CREATE_GROUP              (0x1)
+#define MCAST_EVENT_UPDATE_GROUP              (0x2)
+#define MCAST_EVENT_QUERY_RECV                (0x3)
+#define MCAST_EVENT_REPORT_RECV               (0x4)
+#define MCAST_EVENT_TIMER_EXPIRED             (0x5)
+#define MCAST_NO_REPORT                       (1)
+
+PACKED_STRUCT_DEF mcast_parameters {
+    uint8_t event;
+    uint8_t state;
+    uint8_t general_query;
+    uint8_t filter_mode;
+    uint8_t last_host;
+    uint16_t max_resp_time;
+    union pico_address mcast_link;
+    union pico_address mcast_group;
+    struct pico_tree *MCASTFilter;
+    struct pico_frame *f;
+};
+
+PACKED_STRUCT_DEF pico_mcast_group {
+    uint8_t filter_mode;
+    uint16_t reference_count;
+    union pico_address mcast_addr;
+    struct pico_tree MCASTSources;
+};
+
+PACKED_STRUCT_DEF mcast_filter_parameters {
+    struct mcast_parameters *p;
+    struct pico_tree *allow;
+    struct pico_tree *block;
+    struct pico_tree *filter;
+    uint16_t sources;
+    uint8_t proto;
+    uint8_t record_type;
+    struct pico_mcast_group *g;
+    union pico_link *link;
+};
+
+
+extern int8_t pico_mcast_generate_filter(struct mcast_filter_parameters *filter, struct mcast_parameters *p);
+
+#endif
diff -ruN picotcp/build/include/pico_md5.h stack/picotcp/build/include/pico_md5.h
--- picotcp/build/include/pico_md5.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_md5.h	2023-12-29 11:06:34.275525200 +0100
@@ -0,0 +1,17 @@
+/*********************************************************************
+ *    PicoTCP. Copyright (c) 2015-2017 Altran Intelligent Systems. Some rights reserved.
+ *    See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *
+ *    Authors: Daniele Lacamera
+ *    *********************************************************************/
+
+#ifndef PICO_MD5_INCLUDE
+#define PICO_MD5_INCLUDE
+
+#include <stdint.h>
+#include <stdlib.h>
+
+void pico_md5sum(uint8_t *dst, const uint8_t *src, size_t len);
+void pico_register_md5sum(void (*md5)(uint8_t *, const uint8_t *, size_t));
+
+#endif /* PICO_MD5_INCLUDE */
diff -ruN picotcp/build/include/pico_mdns.h stack/picotcp/build/include/pico_mdns.h
--- picotcp/build/include/pico_mdns.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_mdns.h	2023-12-29 11:06:34.366788100 +0100
@@ -0,0 +1,206 @@
+/* ****************************************************************************
+ *  PicoTCP. Copyright (c) 2014 TASS Belgium NV. Some rights reserved.
+ *  See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+ *  .
+ *  Author: Toon Stegen, Jelle De Vleeschouwer
+ * ****************************************************************************/
+#ifndef INCLUDE_PICO_MDNS
+#define INCLUDE_PICO_MDNS
+
+#include "pico_dns_common.h"
+#include "pico_tree.h"
+#include "pico_ipv4.h"
+
+/* ********************************* CONFIG ***********************************/
+#define PICO_MDNS_PROBE_UNICAST 1       /* Probe queries as QU-questions      */
+#define PICO_MDNS_CONTINUOUS_REFRESH 0  /* Continuously update cache          */
+#define PICO_MDNS_ALLOW_CACHING 1       /* Enable caching on this host		  */
+#define PICO_MDNS_DEFAULT_TTL 120       /* Default TTL of mDNS records        */
+#define PICO_MDNS_SERVICE_TTL 120       /* Default TTL of SRV/TXT/PTR/NSEC    */
+#define PICO_MDNS_PROBE_COUNT 3
+/* Amount of probes to send:
+   RFC6762: 8.1. Probing:
+   250 ms after the first query, the host should send a second; then,
+   250 ms after that, a third.  If, by 250 ms after the third probe, no
+   conflicting Multicast DNS responses have been received, the host may
+   move to the next step, announcing.
+ */
+
+#define PICO_MDNS_ANNOUNCEMENT_COUNT 3
+/* Amount of announcements to send: (we've opted for 1 extra for robustness)
+   RFC6762: 8.3. Announcing:
+   The Multicast DNS responder MUST send at least two unsolicited
+   responses, one second apart.  To provide increased robustness against
+   packet loss, a responder MAY send up to eight unsolicited responses,
+   provided that the interval between unsolicited responses increases by
+   at least a factor of two with every response sent.
+ */
+/* ****************************************************************************/
+
+#define PICO_MDNS_DEST_ADDR4 "224.0.0.251"
+
+/* To make mDNS records unique or shared records */
+#define PICO_MDNS_RECORD_UNIQUE 0x00u
+#define PICO_MDNS_RECORD_SHARED 0x01u
+
+/* To indicate if we reclaim or not */
+#define PICO_MDNS_RECLAIM 1
+#define PICO_MDNS_NO_RECLAIM 0
+
+/* Flag to check for when records are returned, to determine the hostname */
+#define PICO_MDNS_RECORD_HOSTNAME 0x02u
+#define IS_HOSTNAME_RECORD(x) \
+    (((x)->flags) & PICO_MDNS_RECORD_HOSTNAME) ? (1) : (0)
+
+/* --- MDNS resource record --- */
+struct pico_mdns_record
+{
+    struct pico_dns_record *record; /* DNS Resource Record */
+    uint32_t current_ttl;           /* Current TTL */
+    uint8_t flags;                  /* Resource Record flags */
+    uint8_t claim_id;               /* Claim ID number */
+};
+
+/* ****************************************************************************
+ *  Compares 2 mDNS records by type, name AND rdata for a truly unique result
+ *
+ *  @param ra mDNS record A
+ *  @param rb mDNS record B
+ *  @return 0 when records are equal, returns difference when they're not.
+ * ****************************************************************************/
+int
+pico_mdns_record_cmp( void *a, void *b );
+
+/* ****************************************************************************
+ *  Deletes a single mDNS resource record.
+ *
+ *  @param record Void-pointer to mDNS Resource Record. Can be used with pico_-
+ *         tree-destroy.
+ *  @return Returns 0 on success, something else on failure.
+ * ****************************************************************************/
+int
+pico_mdns_record_delete( void **record );
+
+/* ****************************************************************************
+ *  Creates a single standalone mDNS resource record with given name, type and
+ *  data to register on the network.
+ *
+ *  @param url     DNS rrecord name in URL format. Will be converted to DNS
+ *                 name notation format.
+ *  @param _rdata  Memory buffer with data to insert in the resource record. If
+ *				   data of record should contain a DNS name, the name in the
+ *				   databuffer needs to be in URL-format.
+ *  @param datalen The exact length in bytes of the _rdata-buffer. If data of
+ *				   record should contain a DNS name, datalen needs to be
+ *				   pico_dns_strlen(_rdata).
+ *  @param rtype   DNS type of the resource record to be.
+ *  @param rclass  DNS class of the resource record to be.
+ *  @param rttl    DNS ttl of the resource record to be.
+ *  @param flags   You can specify if the mDNS record should be a shared record
+ *                 rather than a unique record.
+ *  @return Pointer to newly created mDNS resource record.
+ * ****************************************************************************/
+struct pico_mdns_record *
+pico_mdns_record_create( const char *url,
+                         void *_rdata,
+                         uint16_t datalen,
+                         uint16_t rtype,
+                         uint32_t rttl,
+                         uint8_t flags );
+
+
+
+/* ****************************************************************************
+ *  Definition of DNS record tree
+ * ****************************************************************************/
+typedef struct pico_tree pico_mdns_rtree;
+#define PICO_MDNS_RTREE_DECLARE(name) \
+    pico_mdns_rtree (name) = {&LEAF, pico_mdns_record_cmp}
+#define PICO_MDNS_RTREE_DESTROY(rtree) \
+    pico_tree_destroy((rtree), pico_mdns_record_delete)
+#define PICO_MDNS_RTREE_ADD(tree, record) \
+    pico_tree_insert((tree), (record))
+
+/* ****************************************************************************
+ *  API-call to query a record with a certain URL and type. First checks the
+ *  Cache for this record. If no cache-entry is found, a query will be sent on
+ *  the wire for this record.
+ *
+ *  @param url      URL to query for.
+ *  @param type     DNS type top query for.
+ *  @param callback Callback to call when records are found for the query.
+ *  @return 0 when query is correctly parsed, something else on failure.
+ * ****************************************************************************/
+int
+pico_mdns_getrecord( const char *url, uint16_t type,
+                     void (*callback)(pico_mdns_rtree *,
+                                      char *,
+                                      void *),
+                     void *arg );
+
+/* ****************************************************************************
+ *  Claim all different mDNS records in a tree in a single API-call. All records
+ *  in tree are called in a single new claim-session.
+ *
+ *  @param rtree    mDNS record tree with records to claim
+ *  @param callback Callback to call when all record are properly claimed.
+ *  @return 0 When claiming didn't horribly fail.
+ * ****************************************************************************/
+int
+pico_mdns_claim( pico_mdns_rtree record_tree,
+                 void (*callback)(pico_mdns_rtree *,
+                                  char *,
+                                  void *),
+                 void *arg );
+
+/* ****************************************************************************
+ *  Tries to claim a hostname for this machine. Claims automatically a
+ *  unique A record with the IPv4-address of this host.
+ *  The hostname won't be set directly when this functions returns,
+ *  but only if the claiming of the unique record succeeded.
+ *  Init-callback will be called when the hostname-record is successfully
+ *  registered.
+ *
+ *  @param url URL to set the hostname to.
+ *  @param arg Argument to pass to the init-callback.
+ *  @return 0 when the host started registering the hostname-record successfully,
+ *          Returns something else when it didn't succeeded.
+ * ****************************************************************************/
+int
+pico_mdns_tryclaim_hostname( const char *url, void *arg );
+
+/* ****************************************************************************
+ *  Get the current hostname for this machine.
+ *
+ *  @return Returns the hostname for this machine when the module is initialised
+ *			Returns NULL when the module is not initialised.
+ * ****************************************************************************/
+const char *
+pico_mdns_get_hostname( void );
+
+/* ****************************************************************************
+ *  Initialises the entire mDNS-module and sets the hostname for this machine.
+ *  Sets up the global mDNS socket properly and calls callback when succeeded.
+ *	Only when the module is properly initialised records can be registered on
+ *  the module.
+ *
+ *  @param hostname URL to set the hostname to.
+ *  @param address  IPv4-address of this host to bind to.
+ *  @param callback Callback to call when the hostname is registered and
+ *					also the global mDNS module callback. Gets called when
+ *					Passive conflicts occur, so changes in records can be
+ *					tracked in this callback.
+ *	@param arg		Argument to pass to the init-callback.
+ *  @return 0 when the module is properly initialised and the host started regis-
+ *			tering the hostname. Returns something else went the host failed
+ *			initialising the module or registering the hostname.
+ * ****************************************************************************/
+int
+pico_mdns_init( const char *hostname,
+                struct pico_ip4 address,
+                void (*callback)(pico_mdns_rtree *,
+                                 char *,
+                                 void *),
+                void *arg );
+
+#endif /* _INCLUDE_PICO_MDNS */
diff -ruN picotcp/build/include/pico_mld.h stack/picotcp/build/include/pico_mld.h
--- picotcp/build/include/pico_mld.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_mld.h	2023-12-29 11:06:34.368772200 +0100
@@ -0,0 +1,119 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012 TASS Belgium NV. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Authors: Roel Postelmans
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_MLD
+#define INCLUDE_PICO_MLD
+
+#define PICO_MLDV1               1
+#define PICO_MLDV2               2
+
+#define PICO_MLD_QUERY  130
+#define PICO_MLD_REPORT 131
+#define PICO_MLD_DONE   132
+#define PICO_MLD_REPORTV2 143
+
+/*RFC 3810 $6.2 */
+#define MLD_HOP_LIMIT 1
+
+/* states */
+#define MLD_STATE_NON_LISTENER              (0x0)
+#define MLD_STATE_DELAYING_LISTENER         (0x1)
+#define MLD_STATE_IDLE_LISTENER             (0x2)
+
+#define PICO_MLD_STATE_CREATE    1
+#define PICO_MLD_STATE_UPDATE    2
+#define PICO_MLD_STATE_DELETE    3
+/* group record types */
+#define MLD_MODE_IS_INCLUDE                  (1)
+#define MLD_MODE_IS_EXCLUDE                  (2)
+#define MLD_CHANGE_TO_INCLUDE_MODE           (3)
+#define MLD_CHANGE_TO_EXCLUDE_MODE           (4)
+#define MLD_ALLOW_NEW_SOURCES            (5)
+#define MLD_BLOCK_OLD_SOURCES            (6)
+/* events */
+
+#define MLD_EVENT_START_LISTENING           (0x1)
+#define MLD_EVENT_STOP_LISTENING            (0x0)
+#define MLD_EVENT_QUERY_RECV                (0x3)
+#define MLD_EVENT_REPORT_RECV               (0x4)
+#define MLD_EVENT_TIMER_EXPIRED             (0x5)
+/*Not needed?*/
+#define MLD_EVENT_DONE_RECV                 (0x1)
+
+#define MLD_EVENT_DELETE_GROUP           (0x0)
+#define MLD_EVENT_CREATE_GROUP           (0x1)
+#define MLD_EVENT_UPDATE_GROUP           (0x2)
+#define MLD_EVENT_QUERY_RECV             (0x3)
+#define MLD_EVENT_REPORT_RECV            (0x4)
+#define MLD_EVENT_TIMER_EXPIRED          (0x5)
+/* (default) Variabels for times/counters */
+/* ALL IN SECONDS */
+#define MLD_ROBUSTNESS                      (2)
+#define MLD_QUERY_INTERVAL                  (125)
+#define MLD_QUERY_RESPONSE_INTERVAL         (10)
+#define MLD_DEFAULT_MAX_RESPONSE_TIME       (100)
+#define MLD_MULTICAST_LISTENER_INTERVAL     (MLD_ROBUSTNESS * MLD_QUERY_INTERVAL) + MLD_QUERY_RESPONSE_INTERVAL
+#define MLD_OTHER_QUERIER_PRESENT_INTERVAL  (MLD_ROBUSTNESS * MLD_QUERY_INTERVAL) + (0.5 * MLD_QUERY_RESPONSE_INTERVAL)
+#define MLD_STARTUP_QUERY_INTERVAL          (0.25 * MLD_QUERY_INTERVAL)
+#define MLD_STARTUP_QUERY_COUNT             MLD_ROBUSTNESS
+#define MLD_LAST_LISTENER_QUERY_INTERVAL    1
+#define MLD_LISTENER_QUERY_COUNT            MLD_ROBUSTNESS
+#define MLD_UNSOLICITED_REPORT_INTERVAL     10
+
+/* custom timers types */
+#define MLD_TIMER_GROUP_REPORT           (1)
+#define MLD_TIMER_V1_QUERIER             (2)
+#define MLD_TIMER_V2_QUERIER             (2)
+
+
+/* Who has send the last report message */
+#define MLD_HOST_LAST                    (0x1)
+#define MLD_HOST_NOT_LAST                (0x0)
+
+
+#define MLD_TIMER_STOPPED                (1)
+#define MLD_MAX_SOURCES                  (89)
+extern struct pico_protocol pico_proto_mld;
+
+struct mld_multicast_address_record {
+    uint8_t type;
+    uint8_t aux_len;
+    uint16_t nbr_src;
+    struct pico_ip6 multicast;
+    struct pico_ip6 src[1];
+};
+
+struct mld_parameters {
+    uint8_t event;
+    uint8_t state;
+    uint8_t general_query;
+    uint8_t filter_mode;
+    uint8_t last_host;
+    uint16_t max_resp_time;
+    struct pico_ip6 mcast_link;
+    struct pico_ip6 mcast_group;
+    struct pico_tree *MCASTFilter;
+    struct pico_frame *f;
+};
+
+struct mld_timer {
+    uint8_t type;
+    uint8_t stopped;
+    pico_time start;
+    pico_time delay;
+    struct pico_ip6 mcast_link;
+    struct pico_ip6 mcast_group;
+    struct pico_frame *f;
+    void (*mld_callback)(struct mld_timer *t);
+};
+
+uint16_t pico_mld_checksum(struct pico_frame *f);
+int pico_mld_process_in(struct pico_frame *f);
+int pico_mld_state_change(struct pico_ip6 *mcast_link, struct pico_ip6 *mcast_group, uint8_t filter_mode, struct pico_tree *_MCASTFilter, uint8_t state);
+#endif /* _INCLUDE_PICO_MLD */
diff -ruN picotcp/build/include/pico_mm.h stack/picotcp/build/include/pico_mm.h
--- picotcp/build/include/pico_mm.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_mm.h	2023-12-29 11:06:34.370756200 +0100
@@ -0,0 +1,98 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Gustav Janssens, Jonas Van Nieuwenberg, Sam Van Den Berge
+ *********************************************************************/
+
+
+#ifndef _INCLUDE_PICO_MM
+#define _INCLUDE_PICO_MM
+
+#include "pico_config.h"
+
+/*
+ * Memory init function, this will create a memory manager instance
+ * A memory_manager page will be created, along with one page of memory
+ * Memory can be asked for via the pico_mem_zalloc function
+ * More memory will be allocated to the memory manager according to its needs
+ * A maximum amount of memory of uint32_t memsize can be allocated
+ */
+void pico_mem_init(uint32_t memsize);
+/*
+ * Memory deinit function, this will free all memory occupied by the current
+ * memory manager instance.
+ */
+void pico_mem_deinit(void);
+/*
+ * Zero-initialized malloc function, will reserve a memory segment of length uint32_t len
+ * This memory will be quickly allocated in a slab of fixed size if possible
+ * or less optimally in the heap for a small variable size
+ * The fixed size of the slabs can be changed dynamically via a statistics engine
+ */
+void*pico_mem_zalloc(size_t len);
+/*
+ * Free function, free a block of memory pointed to by ptr.
+ * Unused memory is only returned to the system's control by pico_mem_cleanup
+ */
+void pico_mem_free(void*ptr);
+/*
+ * This cleanup function will be provided by the memory manager
+ * It can be called during processor downtime
+ * This function will return unused pages to the system's control
+ * Pages are unused if they no longer contain slabs or heap, and they have been idle for a longer time
+ */
+void pico_mem_cleanup(uint32_t timestamp);
+
+
+
+#ifdef PICO_SUPPORT_MM_PROFILING
+/***********************************************************************************************************************
+ ***********************************************************************************************************************
+   MEMORY PROFILING FUNCTIONS
+ ***********************************************************************************************************************
+ ***********************************************************************************************************************/
+/* General info struct */
+struct profiling_data
+{
+    uint32_t free_heap_space;
+    uint32_t free_slab_space;
+    uint32_t used_heap_space;
+    uint32_t used_slab_space;
+};
+
+/*
+ * This function fills up a struct with used and free slab and heap space in the memory manager
+ * The user is responsible for resource managment
+ */
+void pico_mem_profile_collect_data(struct profiling_data*profiling_page_struct);
+
+/*
+ * This function prints the general structure of the memory manager
+ * Printf in this function can be rerouted to send this data over a serial port, or to write it away to memory
+ */
+void pico_mem_profile_scan_data(void);
+
+/*
+ * This function returns the total size that the manager has received from the system
+ * This can give an indication of the total system resource commitment, but keep in mind that
+ * there can be many free blocks in this "used" size
+ * Together with pico_mem_profile_collect_data, this can give a good estimation of the total
+ * resource commitment
+ */
+uint32_t pico_mem_profile_used_size(void);
+
+/*
+ * This function returns a pointer to page 0, the main memory manager housekeeping (struct pico_mem_manager).
+ * This can be used to collect data about the memory in user defined functions.
+ * Use with care!
+ */
+void*pico_mem_profile_manager(void);
+
+/*
+ * paramter manager is a pointer to a struct pico_mem_manager
+ */
+void pico_mem_init_profiling(void*manager, uint32_t memsize);
+#endif /* PICO_SUPPORT_MM_PROFILING */
+
+#endif /* _INCLUDE_PICO_MM */
diff -ruN picotcp/build/include/pico_module_eth.h stack/picotcp/build/include/pico_module_eth.h
--- picotcp/build/include/pico_module_eth.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_module_eth.h	2023-12-29 11:06:34.276847800 +0100
@@ -0,0 +1,33 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef PICO_MODULE_IPV4_H
+#define PICO_MODULE_IPV4_H
+
+struct pico_arp_entry {
+    struct eth dest;
+#ifdef PICO_CONFIG_IPV4
+    struct ipv4 addr_ipv4;
+#endif
+    RB_ENTRY(pico_arp_entry) node;
+};
+
+/* Configured device */
+struct pico_eth_link {
+    struct pico_device *dev;
+    struct eth address;
+    struct eth netmask;
+    RB_ENTRY(pico_eth_link) node;
+};
+
+#ifndef IS_MODULE_ETH
+# define _mod extern
+#else
+# define _mod
+#endif
+_mod struct pico_module pico_module_eth;
+#undef _mod
+
+#endif
diff -ruN picotcp/build/include/pico_nat.h stack/picotcp/build/include/pico_nat.h
--- picotcp/build/include/pico_nat.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_nat.h	2023-12-29 11:06:34.372079100 +0100
@@ -0,0 +1,90 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Authors: Kristof Roelants, Simon Maes, Brecht Van Cauwenberghe
+ *********************************************************************/
+
+#ifndef INCLUDE_PICO_NAT
+#define INCLUDE_PICO_NAT
+#include "pico_frame.h"
+
+#define PICO_NAT_PORT_FORWARD_DEL 0
+#define PICO_NAT_PORT_FORWARD_ADD 1
+
+#ifdef PICO_SUPPORT_NAT
+void pico_ipv4_nat_print_table(void);
+int pico_ipv4_nat_find(uint16_t nat_port, struct pico_ip4 *src_addr, uint16_t src_port, uint8_t proto);
+int pico_ipv4_port_forward(struct pico_ip4 nat_addr, uint16_t nat_port, struct pico_ip4 src_addr, uint16_t src_port, uint8_t proto, uint8_t flag);
+
+int pico_ipv4_nat_inbound(struct pico_frame *f, struct pico_ip4 *link_addr);
+int pico_ipv4_nat_outbound(struct pico_frame *f, struct pico_ip4 *link_addr);
+int pico_ipv4_nat_enable(struct pico_ipv4_link *link);
+int pico_ipv4_nat_disable(void);
+int pico_ipv4_nat_is_enabled(struct pico_ip4 *link_addr);
+#else
+
+#define pico_ipv4_nat_print_table() do {} while(0)
+static inline int pico_ipv4_nat_inbound(struct pico_frame *f, struct pico_ip4 *link_addr)
+{
+    (void)f;
+    (void)link_addr;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_nat_outbound(struct pico_frame *f, struct pico_ip4 *link_addr)
+{
+    (void)f;
+    (void)link_addr;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_nat_enable(struct pico_ipv4_link *link)
+{
+    (void)link;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_nat_disable(void)
+{
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_nat_is_enabled(struct pico_ip4 *link_addr)
+{
+    (void)link_addr;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_nat_find(uint16_t nat_port, struct pico_ip4 *src_addr, uint16_t src_port, uint8_t proto)
+{
+    (void)nat_port;
+    (void)src_addr;
+    (void)src_port;
+    (void)proto;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+
+static inline int pico_ipv4_port_forward(struct pico_ip4 nat_addr, uint16_t nat_port, struct pico_ip4 src_addr, uint16_t src_port, uint8_t proto, uint8_t flag)
+{
+    (void)nat_addr;
+    (void)nat_port;
+    (void)src_addr;
+    (void)src_port;
+    (void)proto;
+    (void)flag;
+    pico_err = PICO_ERR_EPROTONOSUPPORT;
+    return -1;
+}
+#endif
+
+#endif /* _INCLUDE_PICO_NAT */
+
diff -ruN picotcp/build/include/pico_olsr.h stack/picotcp/build/include/pico_olsr.h
--- picotcp/build/include/pico_olsr.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_olsr.h	2023-12-29 11:06:34.374062900 +0100
@@ -0,0 +1,32 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Daniele Lacamera
+ *********************************************************************/
+#ifndef PICO_OLSR_H
+#define PICO_OLSR_H
+
+
+/* Objects */
+struct olsr_route_entry
+{
+    struct olsr_route_entry         *next;
+    uint32_t time_left;
+    struct pico_ip4 destination;
+    struct olsr_route_entry         *gateway;
+    struct pico_device              *iface;
+    uint16_t metric;
+    uint8_t link_type;
+    struct olsr_route_entry         *children;
+    uint16_t ansn;
+    uint16_t seq;
+    uint8_t lq, nlq;
+    uint8_t                         *advertised_tc;
+};
+
+
+void pico_olsr_init(void);
+int pico_olsr_add(struct pico_device *dev);
+struct olsr_route_entry *olsr_get_ethentry(struct pico_device *vif);
+#endif
diff -ruN picotcp/build/include/pico_protocol.h stack/picotcp/build/include/pico_protocol.h
--- picotcp/build/include/pico_protocol.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_protocol.h	2023-12-29 11:06:34.278830800 +0100
@@ -0,0 +1,97 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_PROTOCOL
+#define INCLUDE_PICO_PROTOCOL
+#include "pico_config.h"
+#include "pico_queue.h"
+
+#define PICO_LOOP_DIR_IN   1
+#define PICO_LOOP_DIR_OUT  2
+
+enum pico_layer {
+    PICO_LAYER_DATALINK = 2, /* Ethernet only. */
+    PICO_LAYER_NETWORK = 3, /* IPv4, IPv6, ARP. Arp is there because it communicates with L2 */
+    PICO_LAYER_TRANSPORT = 4, /* UDP, TCP, ICMP */
+    PICO_LAYER_SOCKET = 5   /* Socket management */
+};
+
+enum pico_err_e {
+    PICO_ERR_NOERR = 0,
+    PICO_ERR_EPERM = 1,
+    PICO_ERR_ENOENT = 2,
+    /* ... */
+    PICO_ERR_EINTR = 4,
+    PICO_ERR_EIO = 5,
+    PICO_ERR_ENXIO = 6,
+    /* ... */
+    PICO_ERR_EAGAIN = 11,
+    PICO_ERR_ENOMEM = 12,
+    PICO_ERR_EACCESS = 13,
+    PICO_ERR_EFAULT = 14,
+    /* ... */
+    PICO_ERR_EBUSY = 16,
+    PICO_ERR_EEXIST = 17,
+    /* ... */
+    PICO_ERR_EINVAL = 22,
+    /* ... */
+    PICO_ERR_ENONET = 64,
+    /* ... */
+    PICO_ERR_EPROTO = 71,
+    /* ... */
+    PICO_ERR_ENOPROTOOPT = 92,
+    PICO_ERR_EPROTONOSUPPORT = 93,
+    /* ... */
+    PICO_ERR_EOPNOTSUPP = 95,
+    PICO_ERR_EADDRINUSE = 98,
+    PICO_ERR_EADDRNOTAVAIL = 99,
+    PICO_ERR_ENETDOWN = 100,
+    PICO_ERR_ENETUNREACH = 101,
+    /* ... */
+    PICO_ERR_ECONNRESET = 104,
+    /* ... */
+    PICO_ERR_EISCONN = 106,
+    PICO_ERR_ENOTCONN = 107,
+    PICO_ERR_ESHUTDOWN = 108,
+    /* ... */
+    PICO_ERR_ETIMEDOUT = 110,
+    PICO_ERR_ECONNREFUSED = 111,
+    PICO_ERR_EHOSTDOWN = 112,
+    PICO_ERR_EHOSTUNREACH = 113,
+    /* ... */
+    PICO_ERR_EINPROGRESS = 115,
+};
+
+typedef enum pico_err_e pico_err_t;
+extern volatile pico_err_t pico_err;
+
+#define IS_IPV6(f) (f && f->net_hdr && ((((uint8_t *)(f->net_hdr))[0] & 0xf0) == 0x60))
+#define IS_IPV4(f) (f && f->net_hdr && ((((uint8_t *)(f->net_hdr))[0] & 0xf0) == 0x40))
+
+#define MAX_PROTOCOL_NAME 16
+
+struct pico_protocol {
+    char name[MAX_PROTOCOL_NAME];
+    uint32_t hash;
+    enum pico_layer layer;
+    uint16_t proto_number;
+    struct pico_queue *q_in;
+    struct pico_queue *q_out;
+    struct pico_frame *(*alloc)(struct pico_protocol *self, struct pico_device *dev, uint16_t size); /* Frame allocation. */
+    int (*push)(struct pico_protocol *self, struct pico_frame *p);    /* Push function, for active outgoing pkts from above */
+    int (*process_out)(struct pico_protocol *self, struct pico_frame *p);  /* Send loop. */
+    int (*process_in)(struct pico_protocol *self, struct pico_frame *p);  /* Recv loop. */
+    uint16_t (*get_mtu)(struct pico_protocol *self);
+};
+
+int pico_protocols_loop(int loop_score);
+void pico_protocol_init(struct pico_protocol *p);
+
+int pico_protocol_datalink_loop(int loop_score, int direction);
+int pico_protocol_network_loop(int loop_score, int direction);
+int pico_protocol_transport_loop(int loop_score, int direction);
+int pico_protocol_socket_loop(int loop_score, int direction);
+
+#endif
diff -ruN picotcp/build/include/pico_queue.h stack/picotcp/build/include/pico_queue.h
--- picotcp/build/include/pico_queue.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_queue.h	2023-12-29 11:06:34.280153400 +0100
@@ -0,0 +1,166 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_QUEUE
+#define INCLUDE_PICO_QUEUE
+#include "pico_config.h"
+#include "pico_frame.h"
+
+#define Q_LIMIT 0
+
+#ifndef NULL
+#define NULL ((void *)0)
+#endif
+
+void *pico_mutex_init(void);
+void pico_mutex_deinit(void *mutex);
+void pico_mutex_lock(void *mutex);
+int pico_mutex_lock_timeout(void *mutex, int timeout);
+void pico_mutex_unlock(void *mutex);
+void pico_mutex_unlock_ISR(void *mutex);
+
+struct pico_queue {
+    uint32_t frames;
+    uint32_t size;
+    uint32_t max_frames;
+    uint32_t max_size;
+    struct pico_frame *head;
+    struct pico_frame *tail;
+#ifdef PICO_SUPPORT_MUTEX
+    void *mutex;
+#endif
+    uint8_t shared;
+    uint16_t overhead;
+};
+
+#ifdef PICO_SUPPORT_MUTEX
+#define PICOTCP_MUTEX_LOCK(x) { \
+        if (x == NULL) \
+            x = pico_mutex_init(); \
+        pico_mutex_lock(x); \
+}
+#define PICOTCP_MUTEX_UNLOCK(x) pico_mutex_unlock(x)
+#define PICOTCP_MUTEX_DEL(x) pico_mutex_deinit(x)
+
+#else
+#define PICOTCP_MUTEX_LOCK(x) do {} while(0)
+#define PICOTCP_MUTEX_UNLOCK(x) do {} while(0)
+#define PICOTCP_MUTEX_DEL(x) do {} while(0)
+#endif
+
+#ifdef PICO_SUPPORT_DEBUG_TOOLS
+static void debug_q(struct pico_queue *q)
+{
+    struct pico_frame *p = q->head;
+    dbg("%d: ", q->frames);
+    while(p) {
+        dbg("(%p)-->", p);
+        p = p->next;
+    }
+    dbg("X\n");
+}
+
+#else
+
+#define debug_q(x) do {} while(0)
+#endif
+
+static inline int32_t pico_enqueue(struct pico_queue *q, struct pico_frame *p)
+{
+    if ((q->max_frames) && (q->max_frames <= q->frames))
+        return -1;
+
+#if (Q_LIMIT != 0)
+    if ((Q_LIMIT < p->buffer_len + q->size))
+        return -1;
+
+#endif
+
+    if ((q->max_size) && (q->max_size < (p->buffer_len + q->size)))
+        return -1;
+
+    if (q->shared)
+        PICOTCP_MUTEX_LOCK(q->mutex);
+
+    p->next = NULL;
+    if (!q->head) {
+        q->head = p;
+        q->tail = p;
+        q->size = 0;
+        q->frames = 0;
+    } else {
+        q->tail->next = p;
+        q->tail = p;
+    }
+
+    q->size += p->buffer_len + q->overhead;
+    q->frames++;
+    debug_q(q);
+
+    if (q->shared)
+        PICOTCP_MUTEX_UNLOCK(q->mutex);
+
+    return (int32_t)q->size;
+}
+
+static inline struct pico_frame *pico_dequeue(struct pico_queue *q)
+{
+    struct pico_frame *p = q->head;
+    if (!p)
+        return NULL;
+
+    if (q->frames < 1)
+        return NULL;
+
+    if (q->shared)
+        PICOTCP_MUTEX_LOCK(q->mutex);
+
+    q->head = p->next;
+    q->frames--;
+    q->size -= p->buffer_len - q->overhead;
+    if (q->head == NULL)
+        q->tail = NULL;
+
+    debug_q(q);
+
+    p->next = NULL;
+    if (q->shared)
+        PICOTCP_MUTEX_UNLOCK(q->mutex);
+
+    return p;
+}
+
+static inline struct pico_frame *pico_queue_peek(struct pico_queue *q)
+{
+    struct pico_frame *p = q->head;
+    if (q->frames < 1)
+        return NULL;
+
+    debug_q(q);
+    return p;
+}
+
+static inline void pico_queue_deinit(struct pico_queue *q)
+{
+    if (q->shared) {
+        PICOTCP_MUTEX_DEL(q->mutex);
+    }
+}
+
+static inline void pico_queue_empty(struct pico_queue *q)
+{
+    struct pico_frame *p = pico_dequeue(q);
+    while(p) {
+        pico_frame_discard(p);
+        p = pico_dequeue(q);
+    }
+}
+
+static inline void pico_queue_protect(struct pico_queue *q)
+{
+    q->shared = 1;
+}
+
+#endif
diff -ruN picotcp/build/include/pico_slaacv4.h stack/picotcp/build/include/pico_slaacv4.h
--- picotcp/build/include/pico_slaacv4.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_slaacv4.h	2023-12-29 11:06:34.375386200 +0100
@@ -0,0 +1,18 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Authors: Bogdan Lupu
+ *********************************************************************/
+#ifndef INCLUDE_PICO_SUPPORT_SLAACV4
+#define INCLUDE_PICO_SUPPORT_SLAACV4
+#include "pico_arp.h"
+
+#define PICO_SLAACV4_SUCCESS  0
+#define PICO_SLAACV4_ERROR    1
+
+int     pico_slaacv4_claimip(struct pico_device *dev, void (*cb)(struct pico_ip4 *ip,  uint8_t code));
+void    pico_slaacv4_unregisterip(void);
+
+#endif /* _INCLUDE_PICO_SUPPORT_SLAACV4 */
+
diff -ruN picotcp/build/include/pico_sntp_client.h stack/picotcp/build/include/pico_sntp_client.h
--- picotcp/build/include/pico_sntp_client.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_sntp_client.h	2023-12-29 11:06:34.376708800 +0100
@@ -0,0 +1,23 @@
+/*********************************************************************
+    PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+    See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+    Author: Toon Stegen
+ *********************************************************************/
+#ifndef INCLUDE_PICO_SNTP_CLIENT
+#define INCLUDE_PICO_SNTP_CLIENT
+
+#include "pico_config.h"
+#include "pico_protocol.h"
+
+struct pico_timeval
+{
+    pico_time tv_sec;
+    pico_time tv_msec;
+};
+
+int pico_sntp_sync(const char *sntp_server, void (*cb_synced)(pico_err_t status));
+int pico_sntp_sync_ip(union pico_address *sntp_addr, void (*cb_synced)(pico_err_t status));
+int pico_sntp_gettimeofday(struct pico_timeval *tv);
+
+#endif /* _INCLUDE_PICO_SNTP_CLIENT */
diff -ruN picotcp/build/include/pico_socket.h stack/picotcp/build/include/pico_socket.h
--- picotcp/build/include/pico_socket.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_socket.h	2023-12-29 11:06:34.281476000 +0100
@@ -0,0 +1,263 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_SOCKET
+#define INCLUDE_PICO_SOCKET
+#include "pico_queue.h"
+#include "pico_addressing.h"
+#include "pico_config.h"
+#include "pico_protocol.h"
+#include "pico_tree.h"
+
+#ifdef __linux__
+    #define PICO_DEFAULT_SOCKETQ (16 * 1024) /* Linux host, so we want full throttle */
+#else
+    #define PICO_DEFAULT_SOCKETQ (6 * 1024) /* seems like an acceptable default for small embedded systems */
+#endif
+
+#define PICO_SHUT_RD   1
+#define PICO_SHUT_WR   2
+#define PICO_SHUT_RDWR 3
+
+#ifdef PICO_SUPPORT_IPV4
+# define IS_SOCK_IPV4(s) ((s->net == &pico_proto_ipv4))
+#else
+# define IS_SOCK_IPV4(s) (0)
+#endif
+
+#ifdef PICO_SUPPORT_IPV6
+# define IS_SOCK_IPV6(s) ((s->net == &pico_proto_ipv6))
+#else
+# define IS_SOCK_IPV6(s) (0)
+#endif
+
+
+struct pico_sockport
+{
+    struct pico_tree socks; /* how you make the connection ? */
+    uint16_t number;
+    uint16_t proto;
+};
+
+
+struct pico_socket {
+    struct pico_protocol *proto;
+    struct pico_protocol *net;
+
+    union pico_address local_addr;
+    union pico_address remote_addr;
+
+    uint16_t local_port;
+    uint16_t remote_port;
+
+    struct pico_queue q_in;
+    struct pico_queue q_out;
+
+    void (*wakeup)(uint16_t ev, struct pico_socket *s);
+
+
+#ifdef PICO_SUPPORT_TCP
+    /* For the TCP backlog queue */
+    struct pico_socket *backlog;
+    struct pico_socket *next;
+    struct pico_socket *parent;
+    uint16_t max_backlog;
+    uint16_t number_of_pending_conn;
+#endif
+#ifdef PICO_SUPPORT_MCAST
+    struct pico_tree *MCASTListen;
+#ifdef PICO_SUPPORT_IPV6
+    struct pico_tree *MCASTListen_ipv6;
+#endif
+#endif
+    uint16_t ev_pending;
+
+    struct pico_device *dev;
+
+    /* Private field. */
+    int id;
+    uint16_t state;
+    uint16_t opt_flags;
+    pico_time timestamp;
+    void *priv;
+};
+
+struct pico_remote_endpoint {
+    union pico_address remote_addr;
+    uint16_t remote_port;
+};
+
+
+struct pico_ip_mreq {
+    union pico_address mcast_group_addr;
+    union pico_address mcast_link_addr;
+};
+struct pico_ip_mreq_source {
+    union pico_address mcast_group_addr;
+    union pico_address mcast_source_addr;
+    union pico_address mcast_link_addr;
+};
+
+
+#define PICO_SOCKET_STATE_UNDEFINED       0x0000u
+#define PICO_SOCKET_STATE_SHUT_LOCAL      0x0001u
+#define PICO_SOCKET_STATE_SHUT_REMOTE     0x0002u
+#define PICO_SOCKET_STATE_BOUND           0x0004u
+#define PICO_SOCKET_STATE_CONNECTED       0x0008u
+#define PICO_SOCKET_STATE_CLOSING         0x0010u
+#define PICO_SOCKET_STATE_CLOSED          0x0020u
+
+# define PICO_SOCKET_STATE_TCP                0xFF00u
+# define PICO_SOCKET_STATE_TCP_UNDEF          0x00FFu
+# define PICO_SOCKET_STATE_TCP_CLOSED         0x0100u
+# define PICO_SOCKET_STATE_TCP_LISTEN         0x0200u
+# define PICO_SOCKET_STATE_TCP_SYN_SENT       0x0300u
+# define PICO_SOCKET_STATE_TCP_SYN_RECV       0x0400u
+# define PICO_SOCKET_STATE_TCP_ESTABLISHED    0x0500u
+# define PICO_SOCKET_STATE_TCP_CLOSE_WAIT     0x0600u
+# define PICO_SOCKET_STATE_TCP_LAST_ACK       0x0700u
+# define PICO_SOCKET_STATE_TCP_FIN_WAIT1      0x0800u
+# define PICO_SOCKET_STATE_TCP_FIN_WAIT2      0x0900u
+# define PICO_SOCKET_STATE_TCP_CLOSING        0x0a00u
+# define PICO_SOCKET_STATE_TCP_TIME_WAIT      0x0b00u
+# define PICO_SOCKET_STATE_TCP_ARRAYSIZ       0x0cu
+
+
+/* Socket options */
+# define PICO_TCP_NODELAY                     1
+# define PICO_SOCKET_OPT_TCPNODELAY           0x0000u
+
+# define PICO_IP_MULTICAST_EXCLUDE            0
+# define PICO_IP_MULTICAST_INCLUDE            1
+# define PICO_IP_MULTICAST_IF                 32
+# define PICO_IP_MULTICAST_TTL                33
+# define PICO_IP_MULTICAST_LOOP               34
+# define PICO_IP_ADD_MEMBERSHIP               35
+# define PICO_IP_DROP_MEMBERSHIP              36
+# define PICO_IP_UNBLOCK_SOURCE               37
+# define PICO_IP_BLOCK_SOURCE                 38
+# define PICO_IP_ADD_SOURCE_MEMBERSHIP        39
+# define PICO_IP_DROP_SOURCE_MEMBERSHIP       40
+
+# define PICO_SOCKET_OPT_MULTICAST_LOOP       1
+# define PICO_SOCKET_OPT_KEEPIDLE              4
+# define PICO_SOCKET_OPT_KEEPINTVL             5
+# define PICO_SOCKET_OPT_KEEPCNT               6
+
+#define PICO_SOCKET_OPT_LINGER                13
+
+# define PICO_SOCKET_OPT_RCVBUF               52
+# define PICO_SOCKET_OPT_SNDBUF               53
+
+
+/* Constants */
+# define PICO_IP_DEFAULT_MULTICAST_TTL        1
+# define PICO_IP_DEFAULT_MULTICAST_LOOP       1
+
+#define PICO_SOCKET_TIMEOUT                   5000u /* 5 seconds */
+#define PICO_SOCKET_LINGER_TIMEOUT            3000u /* 3 seconds */
+#define PICO_SOCKET_BOUND_TIMEOUT             30000u /* 30 seconds */
+
+#define PICO_SOCKET_SHUTDOWN_WRITE 0x01u
+#define PICO_SOCKET_SHUTDOWN_READ  0x02u
+#define TCPSTATE(s) ((s)->state & PICO_SOCKET_STATE_TCP)
+
+#define PICO_SOCK_EV_RD 1u
+#define PICO_SOCK_EV_WR 2u
+#define PICO_SOCK_EV_CONN 4u
+#define PICO_SOCK_EV_CLOSE 8u
+#define PICO_SOCK_EV_FIN 0x10u
+#define PICO_SOCK_EV_ERR 0x80u
+
+struct pico_msginfo {
+    struct pico_device *dev;
+    uint8_t ttl;
+    uint8_t tos;
+};
+
+struct pico_socket *pico_socket_open(uint16_t net, uint16_t proto, void (*wakeup)(uint16_t ev, struct pico_socket *s));
+
+int pico_socket_read(struct pico_socket *s, void *buf, int len);
+int pico_socket_write(struct pico_socket *s, const void *buf, int len);
+
+int pico_socket_sendto(struct pico_socket *s, const void *buf, int len, void *dst, uint16_t remote_port);
+int pico_socket_sendto_extended(struct pico_socket *s, const void *buf, const int len,
+                                void *dst, uint16_t remote_port, struct pico_msginfo *msginfo);
+
+int pico_socket_recvfrom(struct pico_socket *s, void *buf, int len, void *orig, uint16_t *local_port);
+int pico_socket_recvfrom_extended(struct pico_socket *s, void *buf, int len, void *orig,
+                                  uint16_t *remote_port, struct pico_msginfo *msginfo);
+
+int pico_socket_send(struct pico_socket *s, const void *buf, int len);
+int pico_socket_recv(struct pico_socket *s, void *buf, int len);
+
+int pico_socket_bind(struct pico_socket *s, void *local_addr, uint16_t *port);
+int pico_socket_getname(struct pico_socket *s, void *local_addr, uint16_t *port, uint16_t *proto);
+int pico_socket_getpeername(struct pico_socket *s, void *remote_addr, uint16_t *port, uint16_t *proto);
+
+int pico_socket_connect(struct pico_socket *s, const void *srv_addr, uint16_t remote_port);
+int pico_socket_listen(struct pico_socket *s, const int backlog);
+struct pico_socket *pico_socket_accept(struct pico_socket *s, void *orig, uint16_t *port);
+int8_t pico_socket_del(struct pico_socket *s);
+
+int pico_socket_setoption(struct pico_socket *s, int option, void *value);
+int pico_socket_getoption(struct pico_socket *s, int option, void *value);
+
+int pico_socket_shutdown(struct pico_socket *s, int mode);
+int pico_socket_close(struct pico_socket *s);
+
+struct pico_frame *pico_socket_frame_alloc(struct pico_socket *s, struct pico_device *dev, uint16_t len);
+struct pico_device *get_sock_dev(struct pico_socket *s);
+
+
+#ifdef PICO_SUPPORT_IPV4
+# define is_sock_ipv4(x) (x->net == &pico_proto_ipv4)
+#else
+# define is_sock_ipv4(x) (0)
+#endif
+
+#ifdef PICO_SUPPORT_IPV6
+# define is_sock_ipv6(x) (x->net == &pico_proto_ipv6)
+#else
+# define is_sock_ipv6(x) (0)
+#endif
+
+#ifdef PICO_SUPPORT_UDP
+# define is_sock_udp(x) (x->proto == &pico_proto_udp)
+#else
+# define is_sock_udp(x) (0)
+#endif
+
+#ifdef PICO_SUPPORT_TCP
+# define is_sock_tcp(x) (x->proto == &pico_proto_tcp)
+#else
+# define is_sock_tcp(x) (0)
+#endif
+
+/* Interface towards transport protocol */
+int pico_transport_process_in(struct pico_protocol *self, struct pico_frame *f);
+struct pico_socket *pico_socket_clone(struct pico_socket *facsimile);
+int8_t pico_socket_add(struct pico_socket *s);
+int pico_transport_error(struct pico_frame *f, uint8_t proto, int code);
+
+/* Socket loop */
+int pico_sockets_loop(int loop_score);
+struct pico_socket*pico_sockets_find(uint16_t local, uint16_t remote);
+/* Port check */
+int pico_is_port_free(uint16_t proto, uint16_t port, void *addr, void *net);
+
+struct pico_sockport *pico_get_sockport(uint16_t proto, uint16_t port);
+
+uint32_t pico_socket_get_mss(struct pico_socket *s);
+int pico_socket_set_family(struct pico_socket *s, uint16_t family);
+
+int pico_count_sockets(uint8_t proto);
+
+#define PICO_SOCKET_SETOPT_EN(socket, index)  (socket->opt_flags |=  (1 << index))
+#define PICO_SOCKET_SETOPT_DIS(socket, index) (socket->opt_flags &= (uint16_t) ~(1 << index))
+#define PICO_SOCKET_GETOPT(socket, index) ((socket->opt_flags & (1u << index)) != 0)
+
+
+#endif
diff -ruN picotcp/build/include/pico_socket_multicast.h stack/picotcp/build/include/pico_socket_multicast.h
--- picotcp/build/include/pico_socket_multicast.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_socket_multicast.h	2023-12-29 11:06:34.283460000 +0100
@@ -0,0 +1,10 @@
+#ifndef PICO_SOCKET_MULTICAST_H
+#define PICO_SOCKET_MULTICAST_H
+int pico_socket_mcast_filter(struct pico_socket *s, union pico_address *mcast_group, union pico_address *src);
+void pico_multicast_delete(struct pico_socket *s);
+int pico_setsockopt_mcast(struct pico_socket *s, int option, void *value);
+int pico_getsockopt_mcast(struct pico_socket *s, int option, void *value);
+int pico_udp_get_mc_ttl(struct pico_socket *s, uint8_t *ttl);
+int pico_udp_set_mc_ttl(struct pico_socket *s, void *_ttl);
+
+#endif
diff -ruN picotcp/build/include/pico_socket_tcp.h stack/picotcp/build/include/pico_socket_tcp.h
--- picotcp/build/include/pico_socket_tcp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_socket_tcp.h	2023-12-29 11:06:34.378692200 +0100
@@ -0,0 +1,33 @@
+#ifndef PICO_SOCKET_TCP_H
+#define PICO_SOCKET_TCP_H
+#include "pico_socket.h"
+
+#ifdef PICO_SUPPORT_TCP
+
+/* Functions/macros: conditional! */
+
+# define IS_NAGLE_ENABLED(s) (!(!(!(s->opt_flags & (1 << PICO_SOCKET_OPT_TCPNODELAY)))))
+int pico_setsockopt_tcp(struct pico_socket *s, int option, void *value);
+int pico_getsockopt_tcp(struct pico_socket *s, int option, void *value);
+int pico_socket_tcp_deliver(struct pico_sockport *sp, struct pico_frame *f);
+void pico_socket_tcp_delete(struct pico_socket *s);
+void pico_socket_tcp_cleanup(struct pico_socket *sock);
+struct pico_socket *pico_socket_tcp_open(uint16_t family);
+int pico_socket_tcp_read(struct pico_socket *s, void *buf, uint32_t len);
+void transport_flags_update(struct pico_frame *, struct pico_socket *);
+
+#else
+#   define pico_getsockopt_tcp(...) (-1)
+#   define pico_setsockopt_tcp(...) (-1)
+#   define pico_socket_tcp_deliver(...) (-1)
+#   define IS_NAGLE_ENABLED(s) (0)
+#   define pico_socket_tcp_delete(...) do {} while(0)
+#   define pico_socket_tcp_cleanup(...) do {} while(0)
+#   define pico_socket_tcp_open(f) (NULL)
+#   define pico_socket_tcp_read(...) (-1)
+#   define transport_flags_update(...) do {} while(0)
+
+#endif
+
+
+#endif
diff -ruN picotcp/build/include/pico_socket_udp.h stack/picotcp/build/include/pico_socket_udp.h
--- picotcp/build/include/pico_socket_udp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_socket_udp.h	2023-12-29 11:06:34.380014800 +0100
@@ -0,0 +1,19 @@
+#ifndef PICO_SOCKET_UDP_H
+#define PICO_SOCKET_UDP_H
+
+struct pico_socket *pico_socket_udp_open(void);
+int pico_socket_udp_deliver(struct pico_sockport *sp, struct pico_frame *f);
+
+
+#ifdef PICO_SUPPORT_UDP
+int pico_setsockopt_udp(struct pico_socket *s, int option, void *value);
+int pico_getsockopt_udp(struct pico_socket *s, int option, void *value);
+#   define pico_socket_udp_recv(s, buf, len, addr, port) pico_udp_recv(s, buf, len, addr, port, NULL)
+#else
+#   define pico_socket_udp_recv(...) (0)
+#   define pico_getsockopt_udp(...) (-1)
+#   define pico_setsockopt_udp(...) (-1)
+#endif
+
+
+#endif
diff -ruN picotcp/build/include/pico_stack.h stack/picotcp/build/include/pico_stack.h
--- picotcp/build/include/pico_stack.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_stack.h	2023-12-29 11:06:34.284783100 +0100
@@ -0,0 +1,92 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_STACK
+#define INCLUDE_PICO_STACK
+#include "pico_config.h"
+#include "pico_frame.h"
+#include "pico_constants.h"
+
+#define PICO_MAX_TIMERS 20
+
+#define PICO_ETH_MRU (1514u)
+#define PICO_IP_MRU (1500u)
+
+/*******************************************************************************
+ *  TRANSPORT LAYER
+ ******************************************************************************/
+
+/* From dev up to socket */
+int32_t pico_transport_receive(struct pico_frame *f, uint8_t proto);
+
+/*******************************************************************************
+ *  NETWORK LAYER
+ ******************************************************************************/
+
+/* From socket down to dev */
+int32_t pico_network_send(struct pico_frame *f);
+
+/* From dev up to socket */
+int32_t pico_network_receive(struct pico_frame *f);
+
+/*******************************************************************************
+ *  DATALINK LAYER
+ ******************************************************************************/
+
+/* From socket down to dev */
+int pico_datalink_send(struct pico_frame *f);
+
+/* From dev up to socket */
+int pico_datalink_receive(struct pico_frame *f);
+
+/*******************************************************************************
+ *  PHYSICAL LAYER
+ ******************************************************************************/
+
+/* Enqueues the frame in the device-queue. From socket down to dev */
+int32_t pico_sendto_dev(struct pico_frame *f);
+
+/* LOWEST LEVEL: interface towards stack from devices */
+/* Device driver will call this function which returns immediately.
+ * Incoming packet will be processed later on in the dev loop.
+ * The zerocopy version will associate the current buffer to the newly created frame.
+ * Warning: the buffer used in the zerocopy version MUST have been allocated using PICO_ZALLOC()
+ */
+int32_t pico_stack_recv(struct pico_device *dev, uint8_t *buffer, uint32_t len);
+int32_t pico_stack_recv_zerocopy(struct pico_device *dev, uint8_t *buffer, uint32_t len);
+int32_t pico_stack_recv_zerocopy_ext_buffer(struct pico_device *dev, uint8_t *buffer, uint32_t len);
+int32_t pico_stack_recv_zerocopy_ext_buffer_notify(struct pico_device *dev, uint8_t *buffer, uint32_t len, void (*notify_free)(uint8_t *buffer));
+struct pico_frame *pico_stack_recv_new_frame(struct pico_device *dev, uint8_t *buffer, uint32_t len);
+
+/* ----- Initialization ----- */
+int pico_stack_init(void);
+
+/* ----- Loop Function. ----- */
+void pico_stack_tick(void);
+void pico_stack_loop(void);
+
+/* ---- Notifications for stack errors */
+int pico_notify_socket_unreachable(struct pico_frame *f);
+int pico_notify_proto_unreachable(struct pico_frame *f);
+int pico_notify_dest_unreachable(struct pico_frame *f);
+int pico_notify_ttl_expired(struct pico_frame *f);
+int pico_notify_frag_expired(struct pico_frame *f);
+int pico_notify_pkt_too_big(struct pico_frame *f);
+
+/* Various. */
+int pico_source_is_local(struct pico_frame *f);
+int pico_frame_dst_is_unicast(struct pico_frame *f);
+void pico_store_network_origin(void *src, struct pico_frame *f);
+uint32_t pico_timer_add(pico_time expire, void (*timer)(pico_time, void *), void *arg);
+uint32_t pico_timer_add_hashed(pico_time expire, void (*timer)(pico_time, void *), void *arg, uint32_t hash);
+void pico_timer_cancel_hashed(uint32_t hash);
+void pico_timer_cancel(uint32_t id);
+uint32_t pico_rand(void);
+void pico_rand_feed(uint32_t feed);
+void pico_to_lowercase(char *str);
+int pico_address_compare(union pico_address *a, union pico_address *b, uint16_t proto);
+int32_t pico_seq_compare(uint32_t a, uint32_t b);
+
+#endif
diff -ruN picotcp/build/include/pico_strings.h stack/picotcp/build/include/pico_strings.h
--- picotcp/build/include/pico_strings.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_strings.h	2023-12-29 11:06:34.381338800 +0100
@@ -0,0 +1,21 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2015-2017 Altran ISY BeNeLux. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+   Author: Michele Di Pede
+ *********************************************************************/
+
+#ifndef PICO_STRINGS_H
+#define PICO_STRINGS_H
+#include <stddef.h>
+#include <stdint.h>
+
+char *get_string_terminator_position(char *const block, size_t len);
+int pico_strncasecmp(const char *const str1, const char *const str2, size_t n);
+size_t pico_strnlen(const char *str, size_t n);
+
+int num2string(int32_t num, char *buf, int len);
+
+#endif
diff -ruN picotcp/build/include/pico_tcp.h stack/picotcp/build/include/pico_tcp.h
--- picotcp/build/include/pico_tcp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_tcp.h	2023-12-29 11:06:34.382661500 +0100
@@ -0,0 +1,106 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_TCP
+#define INCLUDE_PICO_TCP
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_socket.h"
+
+extern struct pico_protocol pico_proto_tcp;
+
+PACKED_STRUCT_DEF pico_tcp_hdr {
+    struct pico_trans trans;
+    uint32_t seq;
+    uint32_t ack;
+    uint8_t len;
+    uint8_t flags;
+    uint16_t rwnd;
+    uint16_t crc;
+    uint16_t urgent;
+};
+
+PACKED_STRUCT_DEF tcp_pseudo_hdr_ipv4
+{
+    struct pico_ip4 src;
+    struct pico_ip4 dst;
+    uint16_t tcp_len;
+    uint8_t res;
+    uint8_t proto;
+};
+
+#define PICO_TCPHDR_SIZE 20
+#define PICO_SIZE_TCPOPT_SYN 20
+#define PICO_SIZE_TCPHDR (uint32_t)(sizeof(struct pico_tcp_hdr))
+
+/* TCP options */
+#define PICO_TCP_OPTION_END         0x00
+#define PICO_TCPOPTLEN_END        1u
+#define PICO_TCP_OPTION_NOOP        0x01
+#define PICO_TCPOPTLEN_NOOP       1
+#define PICO_TCP_OPTION_MSS         0x02
+#define PICO_TCPOPTLEN_MSS        4
+#define PICO_TCP_OPTION_WS          0x03
+#define PICO_TCPOPTLEN_WS         3u
+#define PICO_TCP_OPTION_SACK_OK        0x04
+#define PICO_TCPOPTLEN_SACK_OK       2
+#define PICO_TCP_OPTION_SACK        0x05
+#define PICO_TCPOPTLEN_SACK       2 /* Plus the block */
+#define PICO_TCP_OPTION_TIMESTAMP   0x08
+#define PICO_TCPOPTLEN_TIMESTAMP  10u
+
+/* TCP flags */
+#define PICO_TCP_FIN 0x01u
+#define PICO_TCP_SYN 0x02u
+#define PICO_TCP_RST 0x04u
+#define PICO_TCP_PSH 0x08u
+#define PICO_TCP_ACK 0x10u
+#define PICO_TCP_URG 0x20u
+#define PICO_TCP_ECN 0x40u
+#define PICO_TCP_CWR 0x80u
+
+#define PICO_TCP_SYNACK    (PICO_TCP_SYN | PICO_TCP_ACK)
+#define PICO_TCP_PSHACK    (PICO_TCP_PSH | PICO_TCP_ACK)
+#define PICO_TCP_FINACK    (PICO_TCP_FIN | PICO_TCP_ACK)
+#define PICO_TCP_FINPSHACK (PICO_TCP_FIN | PICO_TCP_PSH | PICO_TCP_ACK)
+#define PICO_TCP_RSTACK    (PICO_TCP_RST | PICO_TCP_ACK)
+
+
+PACKED_STRUCT_DEF pico_tcp_option
+{
+    uint8_t kind;
+    uint8_t len;
+};
+
+struct pico_socket *pico_tcp_open(uint16_t family);
+uint32_t pico_tcp_read(struct pico_socket *s, void *buf, uint32_t len);
+int pico_tcp_initconn(struct pico_socket *s);
+int pico_tcp_input(struct pico_socket *s, struct pico_frame *f);
+uint16_t pico_tcp_checksum(struct pico_frame *f);
+uint16_t pico_tcp_checksum_ipv4(struct pico_frame *f);
+#ifdef PICO_SUPPORT_IPV6
+uint16_t pico_tcp_checksum_ipv6(struct pico_frame *f);
+#endif
+uint16_t pico_tcp_overhead(struct pico_socket *s);
+int pico_tcp_output(struct pico_socket *s, int loop_score);
+int pico_tcp_queue_in_is_empty(struct pico_socket *s);
+int pico_tcp_reply_rst(struct pico_frame *f);
+void pico_tcp_cleanup_queues(struct pico_socket *sck);
+void pico_tcp_notify_closing(struct pico_socket *sck);
+void pico_tcp_flags_update(struct pico_frame *f, struct pico_socket *s);
+int pico_tcp_set_bufsize_in(struct pico_socket *s, uint32_t value);
+int pico_tcp_set_bufsize_out(struct pico_socket *s, uint32_t value);
+int pico_tcp_get_bufsize_in(struct pico_socket *s, uint32_t *value);
+int pico_tcp_get_bufsize_out(struct pico_socket *s, uint32_t *value);
+int pico_tcp_set_keepalive_probes(struct pico_socket *s, uint32_t value);
+int pico_tcp_set_keepalive_intvl(struct pico_socket *s, uint32_t value);
+int pico_tcp_set_keepalive_time(struct pico_socket *s, uint32_t value);
+int pico_tcp_set_linger(struct pico_socket *s, uint32_t value);
+uint16_t pico_tcp_get_socket_mss(struct pico_socket *s);
+int pico_tcp_check_listen_close(struct pico_socket *s);
+
+#endif
diff -ruN picotcp/build/include/pico_tftp.h stack/picotcp/build/include/pico_tftp.h
--- picotcp/build/include/pico_tftp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_tftp.h	2023-12-29 11:06:34.384644400 +0100
@@ -0,0 +1,83 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+ *********************************************************************/
+#ifndef PICO_TFTP_H
+#define PICO_TFTP_H
+
+#include <stdint.h>
+#include <stddef.h>
+
+#define PICO_TFTP_PORT          (69)
+#define PICO_TFTP_PAYLOAD_SIZE  (512)
+
+#define PICO_TFTP_NONE  0
+#define PICO_TFTP_RRQ   1
+#define PICO_TFTP_WRQ   2
+#define PICO_TFTP_DATA  3
+#define PICO_TFTP_ACK   4
+#define PICO_TFTP_ERROR 5
+#define PICO_TFTP_OACK  6
+
+/* Callback user events */
+#define PICO_TFTP_EV_OK    0
+#define PICO_TFTP_EV_OPT   1
+#define PICO_TFTP_EV_ERR_PEER  2
+#define PICO_TFTP_EV_ERR_LOCAL 3
+
+/* TFTP ERROR CODES */
+#define TFTP_ERR_UNDEF     0
+#define TFTP_ERR_ENOENT    1
+#define TFTP_ERR_EACC      2
+#define TFTP_ERR_EXCEEDED  3
+#define TFTP_ERR_EILL      4
+#define TFTP_ERR_ETID      5
+#define TFTP_ERR_EEXIST    6
+#define TFTP_ERR_EUSR      7
+#define TFTP_ERR_EOPT      8
+
+/* Session options */
+#define PICO_TFTP_OPTION_FILE 1
+
+/* timeout: 0 -> adaptative, 1-255 -> fixed */
+#define PICO_TFTP_OPTION_TIME 2
+
+
+#define PICO_TFTP_MAX_TIMEOUT 255
+#define PICO_TFTP_MAX_FILESIZE (65535 * 512 - 1)
+
+struct pico_tftp_session;
+
+struct pico_tftp_session *pico_tftp_session_setup(union pico_address *a, uint16_t family);
+int pico_tftp_set_option(struct pico_tftp_session *session, uint8_t type, int32_t value);
+int pico_tftp_get_option(struct pico_tftp_session *session, uint8_t type, int32_t *value);
+
+int pico_tftp_start_rx(struct pico_tftp_session *session, uint16_t port, const char *filename,
+                       int (*user_cb)(struct pico_tftp_session *session, uint16_t event, uint8_t *block, int32_t len, void *arg), void *arg);
+int pico_tftp_start_tx(struct pico_tftp_session *session, uint16_t port, const char *filename,
+                       int (*user_cb)(struct pico_tftp_session *session, uint16_t event, uint8_t *block, int32_t len, void *arg), void *arg);
+
+int pico_tftp_reject_request(union pico_address *addr, uint16_t port, uint16_t error_code, const char *error_message);
+int32_t pico_tftp_send(struct pico_tftp_session *session, const uint8_t *data, int32_t len);
+
+int pico_tftp_listen(uint16_t family, void (*cb)(union pico_address *addr, uint16_t port, uint16_t opcode, char *filename, int32_t len));
+
+int pico_tftp_parse_request_args(char *args, int32_t len, int *options, uint8_t *timeout, int32_t *filesize);
+
+int pico_tftp_abort(struct pico_tftp_session *session, uint16_t error, const char *reason);
+int pico_tftp_close_server(void);
+
+int pico_tftp_get_file_size(struct pico_tftp_session *session, int32_t *file_size);
+
+/* SPECIFIC APPLICATION DRIVEN FUNCTIONS */
+struct pico_tftp_session *pico_tftp_app_setup(union pico_address *a, uint16_t port, uint16_t family, int *synchro);
+
+int pico_tftp_app_start_rx(struct pico_tftp_session *session, const char *filename);
+int pico_tftp_app_start_tx(struct pico_tftp_session *session, const char *filename);
+
+int32_t pico_tftp_get(struct pico_tftp_session *session, uint8_t *data, int32_t len);
+int32_t pico_tftp_put(struct pico_tftp_session *session, uint8_t *data, int32_t len);
+
+#endif
diff -ruN picotcp/build/include/pico_tree.h stack/picotcp/build/include/pico_tree.h
--- picotcp/build/include/pico_tree.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_tree.h	2023-12-29 11:06:34.286105100 +0100
@@ -0,0 +1,93 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   Author: Andrei Carp <andrei.carp@tass.be>
+ *********************************************************************/
+
+#ifndef PICO_RBTREE_H
+#define PICO_RBTREE_H
+
+#include "pico_config.h"
+
+/* This is used to declare a new tree, leaf root by default */
+#define PICO_TREE_DECLARE(name, compareFunction) \
+    struct pico_tree name = \
+    { \
+        &LEAF, \
+        compareFunction \
+    }
+
+#define USE_PICO_PAGE0_ZALLOC (1)
+#define USE_PICO_ZALLOC (2)
+
+struct pico_tree_node
+{
+    void*keyValue; /* generic key */
+    struct pico_tree_node*parent;
+    struct pico_tree_node*leftChild;
+    struct pico_tree_node*rightChild;
+    uint8_t color;
+};
+
+struct pico_tree
+{
+    struct pico_tree_node *root;  /* root of the tree */
+
+    /* this function directly provides the keys as parameters not the nodes. */
+    int (*compare)(void*keyA, void*keyB);
+};
+
+extern struct pico_tree_node LEAF; /* generic leaf node */
+
+#ifdef PICO_SUPPORT_MM
+void *pico_tree_insert_implementation(struct pico_tree *tree, void *key, uint8_t allocator);
+void *pico_tree_delete_implementation(struct pico_tree *tree, void *key, uint8_t allocator);
+#endif
+
+
+/*
+ * Manipulation functions
+ */
+void *pico_tree_insert(struct pico_tree *tree, void *key);
+void *pico_tree_delete(struct pico_tree *tree, void *key);
+void *pico_tree_findKey(struct pico_tree *tree, void *key);
+void    pico_tree_drop(struct pico_tree *tree);
+int     pico_tree_empty(struct pico_tree *tree);
+struct pico_tree_node *pico_tree_findNode(struct pico_tree *tree, void *key);
+
+void *pico_tree_first(struct pico_tree *tree);
+void *pico_tree_last(struct pico_tree *tree);
+/*
+ * Traverse functions
+ */
+struct pico_tree_node *pico_tree_lastNode(struct pico_tree_node *node);
+struct pico_tree_node *pico_tree_firstNode(struct pico_tree_node *node);
+struct pico_tree_node *pico_tree_next(struct pico_tree_node *node);
+struct pico_tree_node *pico_tree_prev(struct pico_tree_node *node);
+
+/*
+ * For each macros
+ */
+
+#define pico_tree_foreach(idx, tree) \
+    for ((idx) = pico_tree_firstNode((tree)->root); \
+         (idx) != &LEAF; \
+         (idx) = pico_tree_next(idx))
+
+#define pico_tree_foreach_reverse(idx, tree) \
+    for ((idx) = pico_tree_lastNode((tree)->root); \
+         (idx) != &LEAF; \
+         (idx) = pico_tree_prev(idx))
+
+#define pico_tree_foreach_safe(idx, tree, idx2) \
+    for ((idx) = pico_tree_firstNode((tree)->root); \
+         ((idx) != &LEAF) && ((idx2) = pico_tree_next(idx), 1); \
+         (idx) = (idx2))
+
+#define pico_tree_foreach_reverse_safe(idx, tree, idx2) \
+    for ((idx) = pico_tree_lastNode((tree)->root); \
+         ((idx) != &LEAF) && ((idx2) = pico_tree_prev(idx), 1); \
+         (idx) = (idx2))
+
+#endif
diff -ruN picotcp/build/include/pico_udp.h stack/picotcp/build/include/pico_udp.h
--- picotcp/build/include/pico_udp.h	1970-01-01 01:00:00.000000000 +0100
+++ stack/picotcp/build/include/pico_udp.h	2023-12-29 11:06:34.385966800 +0100
@@ -0,0 +1,45 @@
+/*********************************************************************
+   PicoTCP. Copyright (c) 2012-2017 Altran Intelligent Systems. Some rights reserved.
+   See COPYING, LICENSE.GPLv2 and LICENSE.GPLv3 for usage.
+
+   .
+
+ *********************************************************************/
+#ifndef INCLUDE_PICO_UDP
+#define INCLUDE_PICO_UDP
+#include "pico_addressing.h"
+#include "pico_protocol.h"
+#include "pico_socket.h"
+#define PICO_UDP_MODE_UNICAST 0x01
+#define PICO_UDP_MODE_MULTICAST 0x02
+#define PICO_UDP_MODE_BROADCAST 0xFF
+
+struct pico_socket_udp
+{
+    struct pico_socket sock;
+    int mode;
+    uint8_t mc_ttl; /* Multicasting TTL */
+};
+
+
+extern struct pico_protocol pico_proto_udp;
+
+PACKED_STRUCT_DEF pico_udp_hdr {
+    struct pico_trans trans;
+    uint16_t len;
+    uint16_t crc;
+};
+#define PICO_UDPHDR_SIZE 8
+
+struct pico_socket *pico_udp_open(void);
+uint16_t pico_udp_recv(struct pico_socket *s, void *buf, uint16_t len, void *src, uint16_t *port, struct pico_msginfo *msginfo);
+uint16_t pico_udp_checksum_ipv4(struct pico_frame *f);
+
+#ifdef PICO_SUPPORT_IPV6
+uint16_t pico_udp_checksum_ipv6(struct pico_frame *f);
+#endif
+
+
+int pico_udp_setsockopt(struct pico_socket *s, int option, void *value);
+
+#endif
Binary files picotcp/build/lib/libpicotcp.a and stack/picotcp/build/lib/libpicotcp.a differ
Binary files picotcp/build/lib/pico_device.o and stack/picotcp/build/lib/pico_device.o differ
Binary files picotcp/build/lib/pico_frame.o and stack/picotcp/build/lib/pico_frame.o differ
Binary files picotcp/build/lib/pico_md5.o and stack/picotcp/build/lib/pico_md5.o differ
Binary files picotcp/build/lib/pico_protocol.o and stack/picotcp/build/lib/pico_protocol.o differ
Binary files picotcp/build/lib/pico_socket.o and stack/picotcp/build/lib/pico_socket.o differ
Binary files picotcp/build/lib/pico_socket_multicast.o and stack/picotcp/build/lib/pico_socket_multicast.o differ
Binary files picotcp/build/lib/pico_stack.o and stack/picotcp/build/lib/pico_stack.o differ
Binary files picotcp/build/lib/pico_tree.o and stack/picotcp/build/lib/pico_tree.o differ
Binary files picotcp/build/modules/pico_aodv.o and stack/picotcp/build/modules/pico_aodv.o differ
Binary files picotcp/build/modules/pico_arp.o and stack/picotcp/build/modules/pico_arp.o differ
Binary files picotcp/build/modules/pico_dev_loop.o and stack/picotcp/build/modules/pico_dev_loop.o differ
Binary files picotcp/build/modules/pico_dev_ppp.o and stack/picotcp/build/modules/pico_dev_ppp.o differ
Binary files picotcp/build/modules/pico_dev_tap.o and stack/picotcp/build/modules/pico_dev_tap.o differ
Binary files picotcp/build/modules/pico_dhcp_client.o and stack/picotcp/build/modules/pico_dhcp_client.o differ
Binary files picotcp/build/modules/pico_dhcp_common.o and stack/picotcp/build/modules/pico_dhcp_common.o differ
Binary files picotcp/build/modules/pico_dhcp_server.o and stack/picotcp/build/modules/pico_dhcp_server.o differ
Binary files picotcp/build/modules/pico_dns_client.o and stack/picotcp/build/modules/pico_dns_client.o differ
Binary files picotcp/build/modules/pico_dns_common.o and stack/picotcp/build/modules/pico_dns_common.o differ
Binary files picotcp/build/modules/pico_dns_sd.o and stack/picotcp/build/modules/pico_dns_sd.o differ
Binary files picotcp/build/modules/pico_ethernet.o and stack/picotcp/build/modules/pico_ethernet.o differ
Binary files picotcp/build/modules/pico_fragments.o and stack/picotcp/build/modules/pico_fragments.o differ
Binary files picotcp/build/modules/pico_hotplug_detection.o and stack/picotcp/build/modules/pico_hotplug_detection.o differ
Binary files picotcp/build/modules/pico_icmp4.o and stack/picotcp/build/modules/pico_icmp4.o differ
Binary files picotcp/build/modules/pico_icmp6.o and stack/picotcp/build/modules/pico_icmp6.o differ
Binary files picotcp/build/modules/pico_igmp.o and stack/picotcp/build/modules/pico_igmp.o differ
Binary files picotcp/build/modules/pico_ipfilter.o and stack/picotcp/build/modules/pico_ipfilter.o differ
Binary files picotcp/build/modules/pico_ipv4.o and stack/picotcp/build/modules/pico_ipv4.o differ
Binary files picotcp/build/modules/pico_ipv6.o and stack/picotcp/build/modules/pico_ipv6.o differ
Binary files picotcp/build/modules/pico_ipv6_nd.o and stack/picotcp/build/modules/pico_ipv6_nd.o differ
Binary files picotcp/build/modules/pico_mcast.o and stack/picotcp/build/modules/pico_mcast.o differ
Binary files picotcp/build/modules/pico_mdns.o and stack/picotcp/build/modules/pico_mdns.o differ
Binary files picotcp/build/modules/pico_mld.o and stack/picotcp/build/modules/pico_mld.o differ
Binary files picotcp/build/modules/pico_nat.o and stack/picotcp/build/modules/pico_nat.o differ
Binary files picotcp/build/modules/pico_slaacv4.o and stack/picotcp/build/modules/pico_slaacv4.o differ
Binary files picotcp/build/modules/pico_sntp_client.o and stack/picotcp/build/modules/pico_sntp_client.o differ
Binary files picotcp/build/modules/pico_socket_tcp.o and stack/picotcp/build/modules/pico_socket_tcp.o differ
Binary files picotcp/build/modules/pico_socket_udp.o and stack/picotcp/build/modules/pico_socket_udp.o differ
Binary files picotcp/build/modules/pico_strings.o and stack/picotcp/build/modules/pico_strings.o differ
Binary files picotcp/build/modules/pico_tcp.o and stack/picotcp/build/modules/pico_tcp.o differ
Binary files picotcp/build/modules/pico_tftp.o and stack/picotcp/build/modules/pico_tftp.o differ
Binary files picotcp/build/modules/pico_udp.o and stack/picotcp/build/modules/pico_udp.o differ
diff -ruN picotcp/modules/pico_dev_tap.c stack/picotcp/modules/pico_dev_tap.c
--- picotcp/modules/pico_dev_tap.c	2023-12-29 11:12:14.539439300 +0100
+++ stack/picotcp/modules/pico_dev_tap.c	2023-12-29 11:06:34.588996800 +0100
@@ -49,11 +49,763 @@
     return tapdev_link_state;
 }
 
+void hexdump(unsigned char *data, size_t size) {
+        char ascii[17] = {0};
+        size_t i;
+
+        for (i = 0; i < size; ++i) {
+                unsigned char c = data[i];
+                size_t next = i+1;
+                printf("%02X ", c);
+                ascii[i % 16] = isprint(c) ? c : '.';
+                if (next % 8 == 0 || next == size) {
+                        printf(" ");
+                        if (next % 16 == 0) {
+                                printf("|  %s \n", ascii);
+                        } 
+
+                        else if (next == size) {
+                                size_t j;
+                                ascii[size % 16] = '\0';
+                                if (size % 16 <= 8) {
+                                        printf(" ");
+                                }
+                                for (j = size % 16; j < 16; ++j) {
+                                        printf("   "); 
+                                }
+                                printf("|  %s \n", ascii);
+                        }
+                }
+                fflush(stdout);
+        }
+}
+
+
+struct eth_hdr {
+    uint8_t dst[6];
+    uint8_t src[6];
+    uint16_t type;
+} __attribute__((packed));
+
+
+struct ipv4_hdr {
+    uint8_t version_ihl;
+    uint8_t dscp_ecn;
+    uint16_t len;
+    uint16_t id;
+    uint16_t flags_offset;
+    uint8_t ttl;
+    uint8_t proto;
+    uint16_t checksum;
+    uint32_t src;
+    uint32_t dst;
+} __attribute__((packed));
+
+struct icmp4_hdr {
+    uint8_t type;
+    uint8_t code;
+    uint16_t checksum;
+    uint32_t rest;
+} __attribute__((packed));
+
+struct udp_hdr {
+    uint16_t src;
+    uint16_t dst;
+    uint16_t len;
+    uint16_t checksum;
+} __attribute__((packed));
+
+struct tcp_hdr {
+    uint16_t src;
+    uint16_t dst;
+    uint32_t seq;
+    uint32_t ack;
+    uint8_t offset;
+    uint8_t flags;
+    uint16_t window;
+    uint16_t checksum;
+    uint16_t urgent;
+} __attribute__((packed));
+
+void calc_icmp_checksum(struct ipv4_hdr *ipv4, struct icmp4_hdr *icmp, int len) {
+    icmp->checksum = 0;
+    unsigned int sum = 0;
+    unsigned int i;
+    unsigned char *p = (unsigned char *)icmp;
+
+    for (i = 0; i < len/2; i += 2) {
+        sum += (p[i] << 8) + p[i+1];
+    }
+
+    while (sum >> 16) {
+        sum = (sum & 0xffff) + (sum >> 16);
+    }
+
+    icmp->checksum = ~sum;
+}
+
+unsigned char *fuzz_icmp4(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    struct icmp4_hdr *icmp = (struct icmp4_hdr *)(b + sizeof(struct eth_hdr) + ihl );
+
+    if (!(rand() % 10)) {
+        *len -= rand() % *len;
+        printf("fuzzing icmp4 len\n");
+        if (*len > ihl + sizeof(struct eth_hdr)) {
+            calc_icmp_checksum(ipv4, icmp, *len - ihl - sizeof(struct eth_hdr));
+        }
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        icmp->type = rand() % 256;
+        printf("fuzzing icmp4 type\n");
+        calc_icmp_checksum(ipv4, icmp, *len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        icmp->code = rand() % 256;
+        printf("fuzzing icmp4 code\n");
+        calc_icmp_checksum(ipv4, icmp, *len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        icmp->checksum = rand() % 65536;
+        printf("fuzzing icmp4 checksum\n");
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        icmp->rest = rand() % 4294967296;
+        printf("fuzzing icmp4 rest\n");
+        calc_icmp_checksum(ipv4, icmp, *len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    return b;
+}
+
+unsigned char *fuzz_udp(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    struct udp_hdr *udp = (struct udp_hdr *)(b + sizeof(struct eth_hdr) + ihl );
+
+    udp->checksum = 0;
+
+    if (!(rand() % 10)) {
+        *len -= rand() % *len;
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        udp->len = rand() % 65536;
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        udp->checksum = rand() % 65536;
+        return b;
+    }
+
+    return b;
+}
+
+void calc_tcp_checksum(struct ipv4_hdr *ipv4, struct tcp_hdr *tcp, int len) {
+
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    unsigned int tcp_len = len + sizeof(struct tcp_hdr);
+    unsigned int total_len = tcp_len + ihl;
+    unsigned int pseudo_len = tcp_len + 12;
+    unsigned char pseudo[pseudo_len];
+    unsigned int i;
+    unsigned int sum = 0;
+
+    tcp->checksum = 0;
+
+    uint32_t s = ipv4->src;
+    uint32_t d = ipv4->dst;
+
+    memcpy(pseudo, &s, 4);
+    memcpy(pseudo + 4, &d, 4);
+    pseudo[8] = 0;
+    pseudo[9] = ipv4->proto;
+    pseudo[10] = (tcp_len >> 8) & 0xff;
+    pseudo[11] = tcp_len & 0xff;
+    memcpy(pseudo + 12, tcp, tcp_len);
+
+    for (i = 0; i < pseudo_len; i += 2) {
+        sum += (pseudo[i] << 8) + pseudo[i+1];
+    }
+
+    while (sum >> 16) {
+        sum = (sum & 0xffff) + (sum >> 16);
+    }
+
+    tcp->checksum = ~sum;
+}
+
+unsigned char *fuzz_tcp_options_mutate(unsigned char *b, int *len){
+    return b;
+}
+
+unsigned int well_known_tcp_options[] = {
+    2,3,4,5, 8, 16, 17, 34
+};
+
+unsigned int well_known_ip_options[] = {
+    0, 1, 7, 10, 11, 12, 15, 25, 30, 68, 94,  
+    130, 131, 133, 134, 136, 137, 142, 144, 145, 147, 148, 149, 151, 152, 158, 
+    205, 222
+};
+
+int gen_ip_opt_nr() {
+    if (!(rand() % 4)) {
+        // return well known options
+        return well_known_ip_options[rand() % (sizeof(well_known_ip_options) / sizeof(unsigned int))];
+    }
+
+    return rand() % 256;
+}
+
+int gen_tcp_opt_nr() {
+    if (!(rand() % 4)) {
+        // return well known options
+        return well_known_tcp_options[rand() % (sizeof(well_known_tcp_options) / sizeof(unsigned int))];
+    }
+
+    if (rand() % 10)
+        return rand() % 35;
+    else 
+        return rand() % 256;
+
+    return 0;
+}
+
+// -1 is either unspecified or dynamic
+// see https://www.iana.org/assignments/tcp-parameters/tcp-parameters.xhtml
+int known_options_len[] = {
+    2,
+    2,
+    4,
+    3,
+    2,
+    -1, 
+    6,
+    6,
+    10, 
+    2,
+    3,
+    -1,-1,-1, 
+    3, 
+    -1, -1, -1, 
+    3, 
+    18, 
+    -1, -1, -1, -1, -1, -1, -1,
+    8, 
+    4, 
+    -1, -1, -1, -1, -1, -1
+};
+
+int gen_option_len(int o){
+    if (o > 34) {
+        if (rand() % 10) {
+            return rand() % 38 + 2;
+        } else {
+            return rand() % 40;
+        }
+    }
+
+    int olen = known_options_len[o];
+    if (olen == -1 || !(rand() % 10) ) {
+        if (rand() % 10) {
+            return rand() % 38 + 2;
+        } else {
+            return rand() % 40;
+        }
+    }
+
+    return olen;
+
+}
+
+unsigned char *generate_tcp_options(unsigned int *len) {
+    unsigned int olen = rand() % 40  + 1;
+    static char obuf[40];
+    unsigned char *o = obuf;
+    unsigned int i;
+
+    if (olen % 4)
+        olen += 4 - (olen % 4);
+
+    int nr_options = rand() % 10;
+
+    int olen_avail = olen;
+    char *olen_cur_ptr = o;
+
+    for (i = 0; i < nr_options; i++) {
+
+        if (olen_avail < 2) {
+            break;
+        }
+
+        int opt_nr = gen_tcp_opt_nr();
+        int opt_len = gen_option_len(opt_nr);
+        if (opt_len > olen_avail) {
+            opt_len = olen_avail;
+        }
+
+        olen_cur_ptr[0] = opt_nr;
+        olen_cur_ptr[1] = opt_len;
+        olen_cur_ptr += 2;
+        olen_avail -= 2;
+
+        if (opt_len > 2) {
+            int j;
+            for (j = 0; j < opt_len - 2; j++) {
+                olen_cur_ptr[j] = rand() % 256;
+            }
+            olen_cur_ptr += opt_len - 2;
+            olen_avail -= opt_len - 2;
+        }
+
+    }
+
+    *len = olen;
+    return o;
+}
+
+unsigned char *fuzz_tcp_options(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    struct tcp_hdr *tcp = (struct tcp_hdr *)(b + sizeof(struct eth_hdr) + ihl );
+
+    int original_len = *len;
+
+    unsigned int tcp_len = original_len - ihl - sizeof(struct eth_hdr);
+    unsigned int options_len = tcp->offset * 4 - sizeof(struct tcp_hdr);
+
+    if (options_len != 0) {
+        return fuzz_tcp_options_mutate(b, len);
+    }
+
+    unsigned int olen = 0;
+    unsigned char *o = generate_tcp_options(&olen); 
+    printf("fuzzing tcp options\n");
+    unsigned char *p = malloc(original_len + olen + 100);
+
+    memcpy(p, b, sizeof(struct eth_hdr) + ihl + sizeof(struct tcp_hdr));
+    memcpy(p + sizeof(struct eth_hdr) + ihl + sizeof(struct tcp_hdr), o, olen);
+    memcpy(p + sizeof(struct eth_hdr) + ihl + sizeof(struct tcp_hdr) + olen, 
+        b + sizeof(struct eth_hdr) + ihl + sizeof(struct tcp_hdr), 
+        original_len - ihl - sizeof(struct eth_hdr) - sizeof(struct tcp_hdr));
+
+    *len = original_len + olen;
+
+    ipv4 = (struct ipv4_hdr *)(p + sizeof(struct eth_hdr));
+    ihl = (ipv4->version_ihl & 0x0f) * 4;
+    tcp = (struct tcp_hdr *)(p + sizeof(struct eth_hdr) + ihl );
+    tcp->offset = (sizeof(struct tcp_hdr) + olen) / 4;
+    calc_tcp_checksum(ipv4, tcp, *len - ihl - sizeof(struct eth_hdr));
+    // need to signal allocation (msb of len?) so we can avoid leaks
+    return p;
+
+}
+
+uint32_t delta(uint32_t v) {
+    if (rand() % 10) {
+        if (rand() % 2) {
+            return v + rand() % 100;
+        } else {
+            return v - rand() % 100;
+        }
+    } else {
+        return rand() % 4294967296;
+    }
+    return v;
+}
+
+uint16_t delta16(uint16_t v) {
+    if (rand() % 10) {
+        if (rand() % 2) {
+            return v + rand() % 10;
+        } else {
+            return v - rand() % 10;
+        }
+    } else {
+        return rand() % 65536;
+    }
+    return v;
+}
+
+uint8_t delta8(uint8_t v) {
+    if (rand() % 10) {
+        if (rand() % 2) {
+            return v + rand() % 10;
+        } else {
+            return v - rand() % 10;
+        }
+    } else {
+        return rand() % 256;
+    }
+    return v;
+}
+
+unsigned char *fuzz_tcp(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    struct tcp_hdr *tcp = (struct tcp_hdr *)(b + sizeof(struct eth_hdr) + ihl );
+
+    int original_len = *len;
+
+
+    if (!(rand() % 10)) {
+        return fuzz_tcp_options(b, len);
+    }
+
+    if (!(rand() % 10)) {
+        *len -= rand() % *len;
+        return b;
+    }
+
+
+    if (!(rand() % 10)) {
+        tcp->seq = delta(tcp->seq);
+        printf("fuzzing seq\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->ack = delta(tcp->ack);
+        printf("fuzzing ack\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->offset = delta8(tcp->offset);
+        printf("fuzzing offset\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->flags = rand() % 256;
+        printf("fuzzing flags\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->window = delta16(tcp->window);
+        printf("fuzzing window\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->checksum = rand() % 65536;
+        printf("fuzzing checksum\n");
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        tcp->urgent = rand() % 65536;
+        printf("fuzzing urgent\n");
+        calc_tcp_checksum(ipv4, tcp, original_len - ihl - sizeof(struct eth_hdr));
+        return b;
+    }
+
+    return b;
+}
+
+unsigned char* fuzz_ipv4_options_mutate(unsigned char *b, int *len) {
+    return b;
+}
+
+void calc_ip_checksum_ihl(struct ipv4_hdr *ipv4) {
+    ipv4->checksum = 0;
+    unsigned int sum = 0;
+    unsigned int i;
+    unsigned char *p = (unsigned char *)ipv4;
+
+    unsigned int len = 20;
+
+    for (i = 0; i < len/2; i += 2) {
+        sum += (p[i] << 8) + p[i+1];
+    }
+
+    while (sum >> 16) {
+        sum = (sum & 0xffff) + (sum >> 16);
+    }
+
+    ipv4->checksum = ~sum;
+}
+
+void calc_ip_checksum(struct ipv4_hdr *ipv4) {
+    ipv4->checksum = 0;
+    unsigned int sum = 0;
+    unsigned int i;
+    unsigned char *p = (unsigned char *)ipv4;
+
+    unsigned int len = (ipv4->version_ihl & 0x0f) * 4;
+
+    for (i = 0; i < len/2; i += 2) {
+        sum += (p[i] << 8) + p[i+1];
+    }
+
+    while (sum >> 16) {
+        sum = (sum & 0xffff) + (sum >> 16);
+    }
+
+    ipv4->checksum = ~sum;
+}
+
+int gen_ip_option_len(int o){
+    int olen = 2;
+    if (rand() % 10) {
+        olen += rand() % 18;
+    }
+    return olen;
+
+}
+
+
+unsigned char *generate_ipv4_options(int *olen) {
+    unsigned int olen2 = rand() % 20 + 1;
+    static unsigned char obuf[20];
+    unsigned char *o = obuf;
+    unsigned int i;
+
+    if (olen2 % 4)
+        olen2 += 4 - (olen2 % 4);
+
+    int nr_options = rand() % 5;
+
+    int olen_avail = olen2;
+    char *olen_cur_ptr = o;
+
+    for (i = 0; i < nr_options; i++) {
+
+        if (olen_avail < 2) {
+            break;
+        }
+
+        int opt_nr = gen_ip_opt_nr();
+        int opt_len = gen_ip_option_len(opt_nr);
+        if (opt_len > olen_avail) {
+            opt_len = olen_avail;
+        }
+
+        olen_cur_ptr[0] = opt_nr;
+        olen_cur_ptr[1] = opt_len;
+        olen_cur_ptr += 2;
+        olen_avail -= 2;
+
+        if (opt_len > 2) {
+            int j;
+            for (j = 0; j < opt_len - 2; j++) {
+                olen_cur_ptr[j] = rand() % 256;
+            }
+            olen_cur_ptr += opt_len - 2;
+            olen_avail -= opt_len - 2;
+        }
+
+    }
+
+    *olen = olen2;
+    return o;
+}
+
+unsigned char* fuzz_ipv4_options(unsigned char *b, int *len) {
+
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+    unsigned int ihl = (ipv4->version_ihl & 0x0f) * 4;
+    unsigned int options_len = ihl - sizeof(struct ipv4_hdr);
+    unsigned int options_offset = sizeof(struct eth_hdr) + sizeof(struct ipv4_hdr);
+
+    if (options_len != 0) {
+        fuzz_ipv4_options_mutate(b, len);
+        return b;
+    }
+
+    unsigned int olen = 0;
+    unsigned char *o = generate_ipv4_options(&olen);
+
+    printf("fuzzing ipv4 options\n");
+
+    unsigned char *p = malloc(*len + olen + 100);
+
+    memcpy(p, b, options_offset);
+    memcpy(p + options_offset, o, olen);
+    memcpy(p + options_offset + olen, b + options_offset, *len - options_offset);
+
+    eth = (struct eth_hdr *)p;
+    ipv4 = (struct ipv4_hdr *)(p + sizeof(struct eth_hdr));
+
+    ipv4->version_ihl = 0x40 | ((sizeof(struct ipv4_hdr) + olen) / 4);
+
+    calc_ip_checksum(ipv4);
+
+    // signal allocation to caller
+
+    return p;
+
+
+}
+
+unsigned char *fuzz_ipv4_header(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+
+    if (!(rand() % 10)) {
+        *len -= rand() % *len;
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->version_ihl = rand() % 256;
+        printf("fuzzing ipv4 version_ihl\n");
+        calc_ip_checksum_ihl(ipv4);
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->dscp_ecn = rand() % 256;
+        printf("fuzzing ipv4 dscp_ecn\n");
+        calc_ip_checksum(ipv4);
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->len = rand() % 65536;
+        printf("fuzzing ipv4 len\n");
+        calc_ip_checksum(ipv4);
+
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->id = rand() % 65536;
+        printf("fuzzing ipv4 id\n");
+        calc_ip_checksum(ipv4);
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->flags_offset = rand() % 65536;
+        printf("fuzzing ipv4 flags_offset\n");
+        calc_ip_checksum(ipv4);
+
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->ttl = rand() % 256;
+        printf("fuzzing ipv4 ttl\n");
+        calc_ip_checksum(ipv4);
+
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->proto = rand() % 256;
+        printf("fuzzing ipv4 proto\n");
+        calc_ip_checksum(ipv4);
+        return b;
+    }
+
+    if (!(rand() % 10)) {
+        ipv4->checksum = rand() % 65536;
+        printf("fuzzing ipv4 checksum\n");
+        return b;
+    }
+
+    return b;
+
+}
+
+unsigned char* fuzz_ipv4(unsigned char *b, int *len) {
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+    struct ipv4_hdr *ipv4 = (struct ipv4_hdr *)(b + sizeof(struct eth_hdr));
+
+    if (!(rand() % 10)) {
+        return fuzz_ipv4_options(b, len);
+    }
+
+    if (!(rand() % 10)) {
+        return fuzz_ipv4_header(b, len);
+        return b;
+    }
+
+    if (ipv4->proto == PICO_PROTO_ICMP4) {
+        return fuzz_icmp4(b, len);
+    }
+
+    if (ipv4->proto == PICO_PROTO_UDP) {
+        return fuzz_udp(b, len);
+    }
+
+    if (ipv4->proto == PICO_PROTO_TCP) {
+        return fuzz_tcp(b, len);
+    }
+
+    return b;
+}
+
+// XXX TODO
+unsigned char *fuzz_ipv6(unsigned char *b, int *len) {
+    return b;
+}
+
+unsigned char* fuzz(unsigned char *b, int *len) {
+
+    // don't touch half of the packets
+    if (rand() % 2) 
+        return b;
+
+    struct eth_hdr *eth = (struct eth_hdr *)b;
+
+    if (eth->type == 0x0008)
+        return fuzz_ipv4(b, len);
+    
+    if (eth->type == 0xdd86)
+        return fuzz_ipv6(b, len);
+
+    if (!(rand()%10)) {
+        *len -= rand() % *len;
+        return b;
+    }
+
+    return b;
+}
 
 static int pico_tap_send(struct pico_device *dev, void *buf, int len)
 {
     struct pico_device_tap *tap = (struct pico_device_tap *) dev;
-    return (int)write(tap->fd, buf, (uint32_t)len);
+
+//    hexdump(buf, len);
+
+    unsigned char *b = fuzz(buf, &len);
+
+    int need_free = len & 0x80000000;
+    len &= 0x7fffffff;
+
+    int r = (int)write(tap->fd, b, (uint32_t)len);
+
+    if (need_free) {
+        free(b);
+    }
+
+    return r;
 }
 
 static int pico_tap_poll(struct pico_device *dev, int loop_score)
